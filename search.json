[
  {
    "objectID": "usage/index.html",
    "href": "usage/index.html",
    "title": "Quickstart",
    "section": "",
    "text": "The goal of this package is to make the hierarchical and precedence relationships in TextGrids produced by forced alignment accessable and leverageable for analysis or recoding. You can find a quickstart for reading in a TextGrid on this page.",
    "crumbs": [
      "Get Started",
      "Quickstart",
      "Quickstart"
    ]
  },
  {
    "objectID": "usage/index.html#reading-in-a-single-speaker-textgrid",
    "href": "usage/index.html#reading-in-a-single-speaker-textgrid",
    "title": "Quickstart",
    "section": "Reading in a single speaker TextGrid",
    "text": "Reading in a single speaker TextGrid\nTo quickly read in 2 tiered textgrid, like those produced by the Montreal Forced Aligner, import the AlignedTextGrid class and the Word and Phone interval classes.\n\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nAlignedTextGrid can take either a textgrid_path argument, or a textgrid argument for Textgrid objects that have already been created with praatio.\n\nreading_passage = AlignedTextGrid(\n    textgrid_path = \"resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\nreading_passage\n\nAlignedTextGrid with 1 groups, each with [2] tiers. [['Word', 'Phone']]\n\n\nA list of each tier is available at index 0.\n\nreading_passage[0]\n\nTierGroup with 2 tiers. ['Word', 'Phone']\n\n\nYou can access the specific tiers within a TierGroup with the name of the entry class.\n\nreading_passage[0].Word\n\nSequence tier of Word; .superset_class: Top_wp; .subset_class: Phone",
    "crumbs": [
      "Get Started",
      "Quickstart",
      "Quickstart"
    ]
  },
  {
    "objectID": "usage/index.html#multi-talker-textgrids",
    "href": "usage/index.html#multi-talker-textgrids",
    "title": "Quickstart",
    "section": "Multi-talker TextGrids",
    "text": "Multi-talker TextGrids\nTo read in a multi-talker textgrid, with the same Word,Phone organization for each speaker, the same approach works.\n\ntwo_speaker = AlignedTextGrid(\n    textgrid_path = \"resources/KY25A_1.TextGrid\",\n    entry_classes=[Word, Phone]\n)\ntwo_speaker\n\nAlignedTextGrid with 2 groups, each with [2, 2] tiers. [['Word', 'Phone'], ['Word', 'Phone']]\n\n\nThe first speakers‚Äô tiers are available at index 0, and the second speakers tiers are available at index 1.\n\ntwo_speaker[0]\n\nTierGroup with 2 tiers. ['Word', 'Phone']\n\n\n\ntwo_speaker[1]\n\nTierGroup with 2 tiers. ['Word', 'Phone']",
    "crumbs": [
      "Get Started",
      "Quickstart",
      "Quickstart"
    ]
  },
  {
    "objectID": "usage/index.html#accessing-intervals",
    "href": "usage/index.html#accessing-intervals",
    "title": "Quickstart",
    "section": "Accessing intervals",
    "text": "Accessing intervals\nYou can access intervals within a tier via ordinary indexing, looping, list comprehensions, etc.\n\nfor word in two_speaker[0].Word:\n    print(word.label)\n\n\nyeah\n\nwell\nnow\n\nyou\n\nmight\n\nstart\nthat\n\ni\nwas\nborn\nin\n\neighteen\nsixty\nseven\n\nnintey\nthree",
    "crumbs": [
      "Get Started",
      "Quickstart",
      "Quickstart"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/03_tg-mod.html",
    "href": "usage/01_TextGrids/03_tg-mod.html",
    "title": "Modifying a Textgrid",
    "section": "",
    "text": "You can modify a textgrid by adding an additional entry class with the .interleave_class() method.\n\nfrom aligned_textgrid import AlignedTextGrid, custom_classes\n\n\ntwo_speaker = AlignedTextGrid(\n    textgrid_path = \"../resources/KY25A_1.TextGrid\",\n    entry_classes = custom_classes([\"Word\", \"Phone\"])\n)\n\ntwo_speaker\n\nAlignedTextGrid with 2 groups named ['KY25A', 'IVR'] each with [2, 2] tiers. [['Word', 'Phone'], ['Word', 'Phone']]\n\n\nIf we wanted to add a syllable layer in between the Word and Phone tier, we could do so like this.\n\ntwo_speaker.interleave_class(\n    name = \"Syllable\",\n    above = \"Phone\",\n    #below = \"Word\",\n    timing_from = \"below\",\n    copy_labels = True\n)\n\n\ntwo_speaker\n\nAlignedTextGrid with 2 groups named ['KY25A', 'IVR'] each with [3, 3] tiers. [['Word', 'Syllable', 'Phone'], ['Word', 'Syllable', 'Phone']]\n\n\nNow, you can begin building syllables on the Syllable tier using fuse methods. Here‚Äôs the first step.\n\nimport re\n\nfor speaker in two_speaker:\n    for interval in speaker.Syllable:\n        if re.match(r\"[AEIOU]\", interval.label):\n            if not (re.match(r\"[AEIOU]\", interval.prev.label) or \n                    interval.prev.label == \"NG\" or\n                    interval.prev.label == \"#\"):\n                interval.fuse_leftwards()\n\ntwo_speaker[0].Word[10].contains\n\n[Class Syllable, label: S, .superset_class: Word, .super_instance: start, .subset_class: Phone, .subset_list: ['S'],\n Class Syllable, label: T AA1, .superset_class: Word, .super_instance: start, .subset_class: Phone, .subset_list: ['T', 'AA1'],\n Class Syllable, label: R, .superset_class: Word, .super_instance: start, .subset_class: Phone, .subset_list: ['R'],\n Class Syllable, label: T, .superset_class: Word, .super_instance: start, .subset_class: Phone, .subset_list: ['T']]\n\n\n\n\n\nReuseGPLv3",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "Modifying a Textgrid"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html",
    "href": "usage/01_TextGrids/02_tg-info.html",
    "title": "TextGrid and Tier Properties",
    "section": "",
    "text": "There are a few useful pieces of information available at the AlignedTextGrid, TierGroups, and Tier levels\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\ntwo_speaker = AlignedTextGrid(\n    textgrid_path = \"../resources/KY25A_1.TextGrid\",\n    entry_classes= [Word, Phone]\n)",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "TextGrid and Tier Properties"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#tier-names",
    "href": "usage/01_TextGrids/02_tg-info.html#tier-names",
    "title": "TextGrid and Tier Properties",
    "section": "Tier Names",
    "text": "Tier Names\n\n# AlignedTextGrid level\ntwo_speaker.tier_names\n\n[['KY25A - words', 'KY25A - phones'], ['IVR - words', 'IVR - phones']]\n\n\n\n# TierGroup level\ntwo_speaker[0].tier_names\n\n['KY25A - words', 'KY25A - phones']\n\n\n\n# Tier level\ntwo_speaker[0][0].name \n\n'KY25A - words'",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "TextGrid and Tier Properties"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#xmin-and-xmax",
    "href": "usage/01_TextGrids/02_tg-info.html#xmin-and-xmax",
    "title": "TextGrid and Tier Properties",
    "section": "xmin and xmax",
    "text": "xmin and xmax\n\n# aligned textgrid level\n[two_speaker.xmin, two_speaker.xmax]\n\n[0.0, 26.774]\n\n\n\n# tier groups level\n[two_speaker[0].xmin, two_speaker[0].xmax]\n\n[0.0, 26.774]\n\n\n\n# tier level\n[two_speaker[0][0].xmin, two_speaker[0][0].xmax]\n\n[0.0, 26.774]",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "TextGrid and Tier Properties"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#entry-classes",
    "href": "usage/01_TextGrids/02_tg-info.html#entry-classes",
    "title": "TextGrid and Tier Properties",
    "section": "Entry Classes",
    "text": "Entry Classes\n\n# aligned text grid level\ntwo_speaker.entry_classes\n\n[[aligned_textgrid.sequences.word_and_phone.Word,\n  aligned_textgrid.sequences.word_and_phone.Phone],\n [aligned_textgrid.sequences.word_and_phone.Word,\n  aligned_textgrid.sequences.word_and_phone.Phone]]\n\n\n\n# tier group level\ntwo_speaker[0].entry_classes\n\n[aligned_textgrid.sequences.word_and_phone.Word,\n aligned_textgrid.sequences.word_and_phone.Phone]\n\n\n\n# tier level\ntwo_speaker[0][0].entry_class\n\naligned_textgrid.sequences.word_and_phone.Word",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "TextGrid and Tier Properties"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#starts-ends-and-labels",
    "href": "usage/01_TextGrids/02_tg-info.html#starts-ends-and-labels",
    "title": "TextGrid and Tier Properties",
    "section": "Starts, ends and labels",
    "text": "Starts, ends and labels\nThese are only implemented at the tier level.\n\n# every start time\ntwo_speaker[0][0].starts\n\narray([ 0.    , 10.7017, 11.0017, 13.3117, 13.6517, 13.9017, 13.9317,\n       14.9717, 15.0017, 15.3117, 15.4517, 15.9417, 16.3217, 17.0217,\n       17.2117, 17.3317, 17.7917, 18.0917, 18.9517, 19.7717, 20.2717,\n       20.6417, 24.3517, 24.7317, 25.1717])\n\n\n\n# every end time\ntwo_speaker[0][0].ends\n\narray([10.7017, 11.0017, 13.3117, 13.6517, 13.9017, 13.9317, 14.9717,\n       15.0017, 15.3117, 15.4517, 15.9417, 16.3217, 17.0217, 17.2117,\n       17.3317, 17.7917, 18.0917, 18.9517, 19.7717, 20.2717, 20.6417,\n       24.3517, 24.7317, 25.1717, 26.774 ])\n\n\n\n# every label\ntwo_speaker[0][0].labels\n\n['',\n 'yeah',\n '',\n 'well',\n 'now',\n '',\n 'you',\n '',\n 'might',\n '',\n 'start',\n 'that',\n '',\n 'i',\n 'was',\n 'born',\n 'in',\n '',\n 'eighteen',\n 'sixty',\n 'seven',\n '',\n 'nintey',\n 'three',\n '']",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "TextGrid and Tier Properties"
    ]
  },
  {
    "objectID": "usage/05_Outputs/00_to_textgrid.html",
    "href": "usage/05_Outputs/00_to_textgrid.html",
    "title": "Saving Outputting and Saving as a TextGrid",
    "section": "",
    "text": "Each aligned_textgrid object has a .return_*() method that returns its corresponding praatio object.\n\nsequence_interval.return_interval() returns a praatio interval\nsequence_interval.return_tier() returns a praatio interval tier\naligned_textgrid.return_textgrid() returns a praatio TextGrid\n\nHere‚Äôs an example.\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone\n\ntg = AlignedTextGrid(\n    textgrid_path=\"../resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\n\n\n\n\ntg[0].Phone.first.return_interval()\n\nInterval(start=0.0, end=0.11, label='')\n\n\n\n\n\n\ntg[0].Phone.return_tier()\n\n&lt;praatio.data_classes.interval_tier.IntervalTier at 0x123077dc0&gt;\n\n\n\n\n\n\ntg.return_textgrid()\n\n&lt;praatio.data_classes.textgrid.Textgrid at 0x1230776d0&gt;",
    "crumbs": [
      "Get Started",
      "Outputs",
      "Saving Outputting and Saving as a TextGrid"
    ]
  },
  {
    "objectID": "usage/05_Outputs/00_to_textgrid.html#outputting-textgrids",
    "href": "usage/05_Outputs/00_to_textgrid.html#outputting-textgrids",
    "title": "Saving Outputting and Saving as a TextGrid",
    "section": "",
    "text": "Each aligned_textgrid object has a .return_*() method that returns its corresponding praatio object.\n\nsequence_interval.return_interval() returns a praatio interval\nsequence_interval.return_tier() returns a praatio interval tier\naligned_textgrid.return_textgrid() returns a praatio TextGrid\n\nHere‚Äôs an example.\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone\n\ntg = AlignedTextGrid(\n    textgrid_path=\"../resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\n\n\n\n\ntg[0].Phone.first.return_interval()\n\nInterval(start=0.0, end=0.11, label='')\n\n\n\n\n\n\ntg[0].Phone.return_tier()\n\n&lt;praatio.data_classes.interval_tier.IntervalTier at 0x123077dc0&gt;\n\n\n\n\n\n\ntg.return_textgrid()\n\n&lt;praatio.data_classes.textgrid.Textgrid at 0x1230776d0&gt;",
    "crumbs": [
      "Get Started",
      "Outputs",
      "Saving Outputting and Saving as a TextGrid"
    ]
  },
  {
    "objectID": "usage/05_Outputs/00_to_textgrid.html#saving-a-textgrid",
    "href": "usage/05_Outputs/00_to_textgrid.html#saving-a-textgrid",
    "title": "Saving Outputting and Saving as a TextGrid",
    "section": "Saving a TextGrid",
    "text": "Saving a TextGrid\nYou can save an aligned textgrid to a .TextGrid file with the .save_textgrid() method.\n\ntg.save_textgrid(\n    save_path=\"new.TextGrid\"\n)",
    "crumbs": [
      "Get Started",
      "Outputs",
      "Saving Outputting and Saving as a TextGrid"
    ]
  },
  {
    "objectID": "usage/05_Outputs/02_pickling.html",
    "href": "usage/05_Outputs/02_pickling.html",
    "title": "Pickling Aligned TextGrids",
    "section": "",
    "text": "Due to the number of dynamically created classes, the default python pickle library doesn‚Äôt currently work for AlignedTextGrids. However, the cloudpickle library does.\n\nfrom aligned_textgrid import AlignedTextGrid, custom_classes\n\ntg = AlignedTextGrid(\n    textgrid_path=\"../resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=custom_classes([\"Word\", \"Phone\"])\n)\n\n\nimport cloudpickle\nfrom pathlib import Path\n\n\nout_file = Path(\"test.pickle\")\n\n\nwith out_file.open('wb') as f:\n    cloudpickle.dump(tg, f)\n\n\nwith out_file.open('rb') as f:\n    new_tg = cloudpickle.load(f)\n\n\n\n\nReuseGPLv3",
    "crumbs": [
      "Get Started",
      "Outputs",
      "Pickling Aligned TextGrids"
    ]
  },
  {
    "objectID": "usage/02_Sequences/03_sequence-modification.html",
    "href": "usage/02_Sequences/03_sequence-modification.html",
    "title": "Sequence Modification",
    "section": "",
    "text": "Changing the label of a sequence is fairly straightforward. There are also .fuse_leftwards() and .fuse_rightwards() methods.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\nüö® These sequence modification methods are destructive, and cannot be undone.",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Modification"
    ]
  },
  {
    "objectID": "usage/02_Sequences/03_sequence-modification.html#changing-a-sequence-label",
    "href": "usage/02_Sequences/03_sequence-modification.html#changing-a-sequence-label",
    "title": "Sequence Modification",
    "section": "Changing a sequence label",
    "text": "Changing a sequence label\nWe can change the label of a sequence with simple assignment.\n\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\n\n\nAH0.label\n\n'AH0'\n\n\n\nAH0.label = \"IY0\"\nAH0\n\nClass Phone, label: IY0, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Modification"
    ]
  },
  {
    "objectID": "usage/02_Sequences/03_sequence-modification.html#fusing-leftwards-and-rightwards",
    "href": "usage/02_Sequences/03_sequence-modification.html#fusing-leftwards-and-rightwards",
    "title": "Sequence Modification",
    "section": "Fusing Leftwards and Rightwards",
    "text": "Fusing Leftwards and Rightwards\nYou can also merge sequences together with .fuse_leftwards() and .fuse_rightwards()\n\nAH0.fuse_leftwards()\nAH0\n\nClass Phone, label: DH IY0, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp\n\n\nAll of the relevant information and references are updated when this happens.\n\n# precedence is updated\n[AH0.prev.label, AH0.fol.label]\n\n['#', '#']\n\n\n\n# the superset instance is updated\nlen(AH0.inword)\n\n1\n\n\n\nAH0.inword.sub_labels\n\n['DH IY0']\n\n\n\n# the tier is updated\nAH0.intier.labels\n\n['DH IY0', 'D', 'AO1', 'G']\n\n\n\nlen(AH0.intier)\n\n4\n\n\nIf you merge two sequences with subset lists, their subset lists get merged as well.\n\nAH0.inword.fuse_rightwards()\n\n\nAH0.inword.label\n\n'the dog'\n\n\n\nAH0.inword.sub_labels\n\n['DH IY0', 'D', 'AO1', 'G']\n\n\n\nAH0.inword[1]\n\nClass Phone, label: D, .superset_class: Word, .super_instance: the dog, .subset_class: Bottom_wp\n\n\n\nThe fusion label\nBy default, .fuse_leftwards() and .fuse_rightwards() will append the two interval labels together separated by a space. You can adjust this behavior by passing label_fun a fuction that takes two strings as input and returns a single string as output.\n\ndef my_dash_join(left, right):\n    return \"-\".join([left, right])\n\n\nAH0.fol\n\nClass Phone, label: D, .superset_class: Word, .super_instance: the dog, .subset_class: Bottom_wp\n\n\n\nAH0.fuse_rightwards(label_fun=my_dash_join)\n\n\nAH0\n\nClass Phone, label: DH IY0-D, .superset_class: Word, .super_instance: the dog, .subset_class: Bottom_wp",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Modification"
    ]
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html",
    "href": "usage/02_Sequences/02_sequence_properties.html",
    "title": "Sequence Interval Properties",
    "section": "",
    "text": "Let‚Äôs begin with this textgrid.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\ndog = the_dog.tier_groups[0].tier_list[0].sequence_list[1]",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Interval Properties"
    ]
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#the-behavior-of-len-in-and-iteration",
    "href": "usage/02_Sequences/02_sequence_properties.html#the-behavior-of-len-in-and-iteration",
    "title": "Sequence Interval Properties",
    "section": "The behavior of len(), in and iteration",
    "text": "The behavior of len(), in and iteration\n\nlen()\nIf you pass a Sequence Interval to len(), it‚Äôll return the length of its .subset_list.\n\n\n\nSequence in\n\n\n\nlen(dog)\n\n3\n\n\nIf a Sequence Interval doesn‚Äôt have a .subset_list, then len() will return 0.\n\nlen(AH0)\n\n0\n\n\n\n\nin\nIf you want to check whether a specific sequence interval (the actual object, not just the label) is in the .subset_list of another, you can use in.\n\n\n\nSequence in\n\n\n\nAO1 = dog[1]\nAO1 in dog\n\nTrue\n\n\n\nAH0 in dog\n\nFalse\n\n\n\n\nIteration\nA Sequence Interval is iterable over its .subset_list\n\n\n\nsequence iter\n\n\n\nfor segment in dog:\n    print(f\"{segment.label} is in {segment.inword.label}\")\n\nD is in dog\nAO1 is in dog\nG is in dog",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Interval Properties"
    ]
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#subset-sequence-information",
    "href": "usage/02_Sequences/02_sequence_properties.html#subset-sequence-information",
    "title": "Sequence Interval Properties",
    "section": "Subset Sequence Information",
    "text": "Subset Sequence Information\nIn addition to the .start, .end and .label information about each Sequence Interval, if it also has a .subset_list, that same information is accessible with .sub_starts, .sub_ends and .sub_labels.\n\ndog.sub_starts\n\narray([0.30829161, 0.41950136, 0.83568509])\n\n\n\ndog.sub_ends\n\narray([0.41950136, 0.83568509, 0.96658691])\n\n\n\ndog.sub_labels\n\n['D', 'AO1', 'G']\n\n\nThis is a safe way to check if a general phone label is within a word, since just using in on the sequence interval itself checks against specific Sequence Interval objects.\n\n# the label \"G\" is not a Sequence Interval\n\"G\" in dog\n\nFalse\n\n\n\n\"G\" in dog.sub_labels\n\nTrue",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Interval Properties"
    ]
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#hierarchy-strictness",
    "href": "usage/02_Sequences/02_sequence_properties.html#hierarchy-strictness",
    "title": "Sequence Interval Properties",
    "section": "Hierarchy Strictness",
    "text": "Hierarchy Strictness\nThe hierarchy and precedence structure is very ‚Äústrict‚Äù.\n\nA Sequence Interval a can have no more than one .super_instance\nIf a.super_instance is B, then a is in B.subset_list.\nIf a is in B.subset_list, then it is in no other .subset_list.\nIf a is in B.subset_list, then a.super_instance is B\nIf a is not in B.subset_list, then a.super_instance is not B\nIf a.super_instance is not B, then it is not in B.subset_list\n\nSome examples of relationships that cannot be represented are:\n\n\n\nillicit_1\n\n\n\n\n\nillicit_2\n\n\n\n\n\nillicit_3",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Interval Properties"
    ]
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#class-strictness",
    "href": "usage/02_Sequences/02_sequence_properties.html#class-strictness",
    "title": "Sequence Interval Properties",
    "section": "Class Strictness",
    "text": "Class Strictness\nAnother source of strictness is the Sequence Interval class. You can get the class of a specific interval with type()\n\ntype(AH0)\n\naligned_textgrid.sequences.word_and_phone.Phone\n\n\n\ntype(dog)\n\naligned_textgrid.sequences.word_and_phone.Word\n\n\nA horizontal strictness of classes is that the .fol and .prev Segment Intervals must be of the same class.\n\ntry:\n    dog.set_fol(AH0)\nexcept Exception as exc:\n    print(exc)\n\nFollowing segment must be an instance of Word\n\n\nEach class also defines what its (one and only) .superset_class and .subset_class is. For classes at the top of the hierarchy, there is a reserved Top class, and for classes at the bottom of the hierarchy, there is a reserved Bottom class.\n\nWord.subset_class\n\naligned_textgrid.sequences.word_and_phone.Phone\n\n\n\nWord.superset_class\n\naligned_textgrid.sequences.word_and_phone.Top_wp\n\n\nIf a Sequence Interval isn‚Äôt the right class, it can‚Äôt be added to another‚Äôs .subset_class or set as its .super_instance.\n\ntry:\n    AH0.append_subset_list(AO1)\nexcept Exception as exc:\n    print(exc)\n\nThe subset_class was defined as Bottom_wp, but provided subset_instance was Phone\n\n\n\ntry:\n    AH0.set_super_instance(AO1)\nexcept Exception as exc:\n    print(exc)\n\nThe superset_class was defined as Word, but provided super_instance was Phone",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Interval Properties"
    ]
  },
  {
    "objectID": "reference/SequenceList.html",
    "href": "reference/SequenceList.html",
    "title": "SequenceList",
    "section": "",
    "text": "SequenceList(self, *args)\nA list of SequenceIntervals or SequencePoints that remains sorted\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n*args\nSequenceInterval | SequencePoint\nSequenceIntervals or SequencePoints\n()\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nstarts\nnp.array\nAn array of start times\n\n\nends\nnp.array\nAn array of end times\n\n\nlabels\nlist[str]\nA list of labels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nappend\nAppend a SequenceInterval to the list.\n\n\nconcat\nConcatenate two sequence lists\n\n\npop\nPop a SequenceInterval\n\n\nremove\nRemove a SequenceInterval from the list\n\n\n\n\n\nSequenceList.append(value, shift=False, re_init=False)\nAppend a SequenceInterval to the list.\nAfter appending, the SequenceIntervals are re-sorted\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nSequenceInterval\nA SequenceInterval to append\nrequired\n\n\n\n\n\n\n\nSequenceList.concat(intervals)\nConcatenate two sequence lists\nIn concatenation, the time values of intervals are time shfted by the end time of the original SequenceList.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nintervals\nSequence[SeqVar]\nA list or SequenceList of SequenceIntervals or SequencePoints\nrequired\n\n\n\n\n\n\n\nSequenceList.pop(x)\nPop a SequenceInterval\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nSequenceInterval\nSequenceInterval to pop\nrequired\n\n\n\n\n\n\n\nSequenceList.remove(x)\nRemove a SequenceInterval from the list\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nSequenceInterval\nThe SequenceInterval to remove.\nrequired",
    "crumbs": [
      "SequenceList",
      "SequenceList"
    ]
  },
  {
    "objectID": "reference/SequenceList.html#parameters",
    "href": "reference/SequenceList.html#parameters",
    "title": "SequenceList",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\n*args\nSequenceInterval | SequencePoint\nSequenceIntervals or SequencePoints\n()",
    "crumbs": [
      "SequenceList",
      "SequenceList"
    ]
  },
  {
    "objectID": "reference/SequenceList.html#attributes",
    "href": "reference/SequenceList.html#attributes",
    "title": "SequenceList",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nstarts\nnp.array\nAn array of start times\n\n\nends\nnp.array\nAn array of end times\n\n\nlabels\nlist[str]\nA list of labels",
    "crumbs": [
      "SequenceList",
      "SequenceList"
    ]
  },
  {
    "objectID": "reference/SequenceList.html#methods",
    "href": "reference/SequenceList.html#methods",
    "title": "SequenceList",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nappend\nAppend a SequenceInterval to the list.\n\n\nconcat\nConcatenate two sequence lists\n\n\npop\nPop a SequenceInterval\n\n\nremove\nRemove a SequenceInterval from the list\n\n\n\n\n\nSequenceList.append(value, shift=False, re_init=False)\nAppend a SequenceInterval to the list.\nAfter appending, the SequenceIntervals are re-sorted\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nSequenceInterval\nA SequenceInterval to append\nrequired\n\n\n\n\n\n\n\nSequenceList.concat(intervals)\nConcatenate two sequence lists\nIn concatenation, the time values of intervals are time shfted by the end time of the original SequenceList.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nintervals\nSequence[SeqVar]\nA list or SequenceList of SequenceIntervals or SequencePoints\nrequired\n\n\n\n\n\n\n\nSequenceList.pop(x)\nPop a SequenceInterval\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nSequenceInterval\nSequenceInterval to pop\nrequired\n\n\n\n\n\n\n\nSequenceList.remove(x)\nRemove a SequenceInterval from the list\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nSequenceInterval\nThe SequenceInterval to remove.\nrequired",
    "crumbs": [
      "SequenceList",
      "SequenceList"
    ]
  },
  {
    "objectID": "reference/SequenceInterval.html",
    "href": "reference/SequenceInterval.html",
    "title": "SequenceInterval",
    "section": "",
    "text": "sequences.sequences.SequenceInterval(self, interval=(None, None, None), *, Interval=None)\nA class to describe an interval with precedence relationships and hierarchical relationships",
    "crumbs": [
      "Sequence Classes",
      "Intervals",
      "SequenceInterval"
    ]
  },
  {
    "objectID": "reference/SequenceInterval.html#parameters",
    "href": "reference/SequenceInterval.html#parameters",
    "title": "SequenceInterval",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninterval\nlist | tuple | Interval | Self\nA Praat textgrid Interval. This could one of: i) A list or tuple of start, end and label values (e.g.¬†[0, 1, \"foo\"]); ii) A praatio.utilities.constants.Interval iii) Another SequenceInterval. In this last case, only the start, end and label values from the original SequenceInterval are preserved in the new one.\n(None, None, None)",
    "crumbs": [
      "Sequence Classes",
      "Intervals",
      "SequenceInterval"
    ]
  },
  {
    "objectID": "reference/SequenceInterval.html#examples",
    "href": "reference/SequenceInterval.html#examples",
    "title": "SequenceInterval",
    "section": "Examples",
    "text": "Examples\nA new SequenceInterval can be created from scratch by passing it a tuple of a start time, end time, and a label\n\nfrom aligned_textgrid import SequenceInterval\n\nsample_interval = SequenceInterval((0, 1, \"sample\"))\nprint(sample_interval)\n\nClass SequenceInterval, label: sample, .superset_class: Top, .super_instance, None, .subset_class: Bottom\n\n\nYou can pass a SequenceInterval to another SequenceInterval or subclass (like Word) as well\n\nfrom aligned_textgrid import Word\n\nsample_word = Word(sample_interval)\nprint(sample_word)\n\nClass Word, label: sample, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone",
    "crumbs": [
      "Sequence Classes",
      "Intervals",
      "SequenceInterval"
    ]
  },
  {
    "objectID": "reference/SequenceInterval.html#attributes",
    "href": "reference/SequenceInterval.html#attributes",
    "title": "SequenceInterval",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nstart\nfloat\nStart time of the interval\n\n\nend\nfloat\nEnd time of the interval\n\n\nlabel\nAny\nLabel of the interval\n\n\nduration\nfloat\nThe duration of the interval\n\n\nintier\nSequenceTier\nThe sequence tier the current interval is within.\n\n\ntier_index\nint\nThe index of sequence within its tier.\n\n\nfol\nSequenceInterval\nInstance of the following interval. Is the same subclass as the current instance.\n\n\nprev\nSequenceInterval\nInstance of the previous interval. Is the same subclass as current instance.\n\n\nsuper_instance\nSequenceInterval\nThe instance of the superset. Cannot be the same subclass as the current instance.\n\n\nsubset_list\nlist[SequenceInterval]\nA list of subset instances. Cannot be the same subclass of the current instance.\n\n\nsub_starts\nnumpy.ndarray\nA numpy array of start times for the subset list\n\n\nsub_ends\nnumpy.ndarray\nA numpy array of end times for the subset list\n\n\nsub_labels\nlist[Any]\nA list of labels from the subset list",
    "crumbs": [
      "Sequence Classes",
      "Intervals",
      "SequenceInterval"
    ]
  },
  {
    "objectID": "reference/SequenceInterval.html#methods",
    "href": "reference/SequenceInterval.html#methods",
    "title": "SequenceInterval",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nfuse_leftwards\nFuse the current segment with the previous segment\n\n\nfuse_rightwards\nFuse the current segment with the following segment\n\n\nindex\nReturns subset instance index\n\n\npop\nPop a sequence interval from the subset list\n\n\nset_feature\nSets arbitrary object attribute\n\n\n\n\nfuse_leftwards\nsequences.sequences.SequenceInterval.fuse_leftwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the previous segment\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\nfuse_rightwards\nsequences.sequences.SequenceInterval.fuse_rightwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the following segment\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\nindex\nsequences.sequences.SequenceInterval.index(subset_instance)\nReturns subset instance index\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA subset instance to get the index of.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of subset_instance\n\n\n\n\n\n\npop\nsequences.sequences.SequenceInterval.pop(subset_instance)\nPop a sequence interval from the subset list\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA sequence interval to pop\nrequired\n\n\n\n\n\n\nset_feature\nsequences.sequences.SequenceInterval.set_feature(feature, value)\nSets arbitrary object attribute\nThis will be most useful for creating custom subclasses.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfeature\nstr\nNew attribute name\nrequired\n\n\nvalue\nAny\nNew attribute value\nrequired",
    "crumbs": [
      "Sequence Classes",
      "Intervals",
      "SequenceInterval"
    ]
  },
  {
    "objectID": "reference/SequenceTier.html",
    "href": "reference/SequenceTier.html",
    "title": "SequenceTier",
    "section": "",
    "text": "sequences.tiers.SequenceTier(self, tier=SequenceList(), entry_class=None)\nA sequence tier\nGiven a praatio IntervalTier or list of Intervals, creates entry_class instances for every interval.\nIn addition to the attributes and methods described below, the attributes and methods from TierMixins and WithinMixins are also available.",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequenceTier"
    ]
  },
  {
    "objectID": "reference/SequenceTier.html#parameters",
    "href": "reference/SequenceTier.html#parameters",
    "title": "SequenceTier",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nlist[Interval] | list[SequenceInterval] | IntervalTier | Self\nA list of interval entries. Defaults to SequenceList().\nSequenceList()\n\n\nentry_class\nType[SequenceInterval]\nThe sequence class for this tier. Defaults to SequenceInterval.\nNone",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequenceTier"
    ]
  },
  {
    "objectID": "reference/SequenceTier.html#examples",
    "href": "reference/SequenceTier.html#examples",
    "title": "SequenceTier",
    "section": "Examples",
    "text": "Examples\n\nfrom aligned_textgrid import SequenceInterval, Word, SequenceTier\n\nthe = Word((0,1, \"the\"))\ndog = Word((0,1,\"dog\"))\n\nword_tier = SequenceTier([the, dog])\n\nprint(word_tier)\n\nSequence tier of Word; .superset_class: Top_wp; .subset_class: Phone\n\n\n\nprint(word_tier.sequence_list)\n\n[Class Word, label: the, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, Class Word, label: dog, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone]",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequenceTier"
    ]
  },
  {
    "objectID": "reference/SequenceTier.html#attributes",
    "href": "reference/SequenceTier.html#attributes",
    "title": "SequenceTier",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nsequence_list\nSequenceList[SequenceInterval]\nA SequenceList of intervals in the tier.\n\n\nentry_class\nType[SequenceInterval]\nThe entry class of the tier\n\n\nsuperset_class\nType[SequenceInterval]\nThe superset class of the tier\n\n\nsubset_class\nType[SequenceInterval]\nThe subset class of the tier\n\n\nstarts\nnp.ndarray[np.float64]\nAn array of start times for all intervals\n\n\nends\nnp.ndarray[np.float64]\nAn array of end times for all intervals\n\n\nlabels\nlist[str]\nA list of the labels of all intervals\n\n\nxmin\nfloat\nThe minimum start time of the tier\n\n\nxmax\nfloat\nThe minumum end time of the tier\n\n\nname\nstr\nThe name of the tier\n\n\n[]\n\nIndexable. Returns a SequenceInterval\n\n\n\n\nIterable",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequenceTier"
    ]
  },
  {
    "objectID": "reference/SequenceTier.html#methods",
    "href": "reference/SequenceTier.html#methods",
    "title": "SequenceTier",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nInsert empty intervals where there are gaps in the existing tier.\n\n\nget_interval_at_time\nGets interval index at specified time\n\n\npop\nPop an interval\n\n\nreturn_tier\nReturns a praatio interval tier\n\n\nsave_as_tg\nSaves as a textgrid\n\n\n\n\ncleanup\nsequences.tiers.SequenceTier.cleanup()\nInsert empty intervals where there are gaps in the existing tier.\n\n\nget_interval_at_time\nsequences.tiers.SequenceTier.get_interval_at_time(time)\nGets interval index at specified time\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime at which to get an interval\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nint\nIndex of the interval\n\n\n\n\n\n\npop\nsequences.tiers.SequenceTier.pop(entry)\nPop an interval\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSequenceInterval\nInterval to pop\nrequired\n\n\n\n\n\n\nreturn_tier\nsequences.tiers.SequenceTier.return_tier()\nReturns a praatio interval tier\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.data_classes.interval_tier.IntervalTier\nA praatio interval tier. Useful for saving results back as a Praat TextGrid.\n\n\n\n\n\n\nsave_as_tg\nsequences.tiers.SequenceTier.save_as_tg(save_path)\nSaves as a textgrid\nUses praatio.data_classes.textgrid.Textgrid.save() method.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\nOutput path\nrequired",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequenceTier"
    ]
  },
  {
    "objectID": "reference/TierMixins.html",
    "href": "reference/TierMixins.html",
    "title": "TierMixins",
    "section": "",
    "text": "mixins.tiermixins.TierMixins()\nMethods and attributes for Sequence Tiers",
    "crumbs": [
      "Tiers",
      "Common Features",
      "TierMixins"
    ]
  },
  {
    "objectID": "reference/TierMixins.html#attributes",
    "href": "reference/TierMixins.html#attributes",
    "title": "TierMixins",
    "section": "Attributes",
    "text": "Attributes\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n[]\n\nindexable and iterable\n\n\nfirst\nSequenceInterval\nThe first entry in the tier.\n\n\nlast\nSequenceInterval\nThe last entry in the tier.",
    "crumbs": [
      "Tiers",
      "Common Features",
      "TierMixins"
    ]
  },
  {
    "objectID": "reference/TierMixins.html#methods",
    "href": "reference/TierMixins.html#methods",
    "title": "TierMixins",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nappend\nAppend a new SequenceInterval or Sequence Point to a tier.\n\n\nconcat\nHorizontally concatenate a new tier.\n\n\n\n\nappend\nmixins.tiermixins.TierMixins.append(new, re_relate=True)\nAppend a new SequenceInterval or Sequence Point to a tier.\nIf the tier is already in a TierGroup, and an appended SequenceInterval already has a subset_list, or super_instance, these will be appended to the appropriate tiers above and below.\n\nExamples\n\nfrom aligned_textgrid import SequenceTier, TierGroup, Word, Phone\n\n1word_tier = SequenceTier([\n    Word((0,10, \"the\"))\n])\nphone_tier = SequenceTier([\n    Phone((0,5,\"DH\")),\n    Phone((5,10, \"AH0\"))\n])\n\n2tier_group = TierGroup([word_tier, phone_tier])\n\n3dog = Word((10, 25, \"dog\"))\ndog.append(Phone((10,15, \"D\")))\ndog.append(Phone((15, 20, \"AO1\")))\ndog.append(Phone((20,25, \"G\")))\n\n4word_tier.append(dog)\n\n5print(phone_tier.labels)\n\n\n1\n\nCreation of Word and Phone tier containing ‚Äúthe‚Äù and its phones.\n\n2\n\nRelating the Word and Phone tiers within a tier group.\n\n3\n\nCreating a Word for ‚Äúdog‚Äù and appending its phones.\n\n4\n\nAppending the ‚Äúdog‚Äù word to the Word tier.\n\n5\n\nThe phones of ‚Äúdog‚Äù have been automatically appended to the Phone tier.\n\n\n\n\n['DH', 'AH0', 'D', 'AO1', 'G']\n\n\n\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nSequenceInterval | SequencePoint\nThe SequenceInterval or SequencePoint object to append\nrequired\n\n\nre_relate\nbool\nIf the tier is already within a TierGroup, whether or not to re-run tier-relation. Defaults to True.\nTrue\n\n\n\n\n\n\nconcat\nmixins.tiermixins.TierMixins.concat(new)\nHorizontally concatenate a new tier.\nThis will horizontally concatenate the new tier onto the existing tier. The time values of new will be rightward shifted according to the end of the original tier.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nTierType\nThe tier to concatenate.\nrequired",
    "crumbs": [
      "Tiers",
      "Common Features",
      "TierMixins"
    ]
  },
  {
    "objectID": "reference/Misc.html",
    "href": "reference/Misc.html",
    "title": "Misc",
    "section": "",
    "text": "Misc\npolar.polar_classes.Misc()\nMisc points\n\n\n\n\nReuseGPLv3",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "Misc"
    ]
  },
  {
    "objectID": "reference/custom_classes.html",
    "href": "reference/custom_classes.html",
    "title": "custom_classes",
    "section": "",
    "text": "custom_classes.custom_classes(class_list=[], return_order=None, points=[])\nGenerate custom interval classes\nPassing custom_classes() a list of Sequence names wil return a list of SequenceInterval subclasses with those names. The first name passed to class_list will be at the top of the hierarchy, the second name will be the subset class of the first, and so on.",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes"
    ]
  },
  {
    "objectID": "reference/custom_classes.html#examples",
    "href": "reference/custom_classes.html#examples",
    "title": "custom_classes",
    "section": "Examples",
    "text": "Examples\nTo change the order in which the custom classes are returned, specify return_order with either indices or class names. For example, if you have Words, Syllables, and Phones in a hierarchical relationship in a textgrid, you can run the following:\n\nfrom aligned_textgrid import custom_classes\n\ncustom_classes([\"Word\", \"Syllable\", \"Phone\"])\n\n[aligned_textgrid.sequences.sequences.Word,\n aligned_textgrid.sequences.sequences.Syllable,\n aligned_textgrid.sequences.sequences.Phone]\n\n\nBut if the order of the textgrid tiers has Word as the bottom tier and Phone as the top, you can specify return_order like so:\n\ncustom_classes(\n    class_list = [\"Word\", \"Syllable\", \"Phone\"],\n    return_order = [2, 1, 0]\n    # or\n    # return_order = [\"Phone\", \"Syllable\", \"Word]\n)\n\n[aligned_textgrid.sequences.sequences.Phone,\n aligned_textgrid.sequences.sequences.Syllable,\n aligned_textgrid.sequences.sequences.Word]\n\n\nThis way, you can use custom_classes() directly as the entry_classes argument in AlignedTextGrid\nAlignedTextGrid(\n    textgrid_path = \"syllables.TextGrid\",\n    entry_classes = custom_classes(\n        class_list = [\"Word\", \"Syllable\", \"Phone\"],\n        return_order = [2, 1, 0]\n    )\n)",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes"
    ]
  },
  {
    "objectID": "reference/custom_classes.html#parameters",
    "href": "reference/custom_classes.html#parameters",
    "title": "custom_classes",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclass_list\nlist[str]\nA list of desired class names, in their hierarchical order. Defaults to [].\n[]\n\n\nreturn_order\nlist[str] | list[int] | None\nA return order for the custom classes, if not in hierarchical order. Defaults to None.\nNone\n\n\npoints\nlist[int]\nIndices of which classes should be points, rather than intervals\n[]",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes"
    ]
  },
  {
    "objectID": "reference/custom_classes.html#returns",
    "href": "reference/custom_classes.html#returns",
    "title": "custom_classes",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nlist[Type[SequenceInterval]]\nA list of custom SequenceInterval subclasses",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes"
    ]
  },
  {
    "objectID": "reference/TierGroupMixins.html",
    "href": "reference/TierGroupMixins.html",
    "title": "TierGroupMixins",
    "section": "",
    "text": "mixins.tiermixins.TierGroupMixins()\nMethods and attributes for grouped tiers",
    "crumbs": [
      "Tiers",
      "Common Features",
      "TierGroupMixins"
    ]
  },
  {
    "objectID": "reference/TierGroupMixins.html#attributes",
    "href": "reference/TierGroupMixins.html#attributes",
    "title": "TierGroupMixins",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\n[]\n\nIndexable and iterable",
    "crumbs": [
      "Tiers",
      "Common Features",
      "TierGroupMixins"
    ]
  },
  {
    "objectID": "reference/TierGroupMixins.html#methods",
    "href": "reference/TierGroupMixins.html#methods",
    "title": "TierGroupMixins",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nappend\nAppend a new tier to a TierGroup.\n\n\nconcat\nHorizontally concatenate a tier group.\n\n\n\n\nappend\nmixins.tiermixins.TierGroupMixins.append(new)\nAppend a new tier to a TierGroup.\nThis will add a new tier to a TierGroup\n\nExamples\n\nfrom aligned_textgrid import TierGroup, SequenceTier, Word, Phone\n\nword_tier = SequenceTier([\n    Word((0,10,\"the\"))\n])\nphone_tier = SequenceTier([\n    Phone((0,5,\"DH\")),\n    Phone((5,10,\"AH0\"))\n])\n\ntier_group = TierGroup([word_tier])\ntier_group.append(phone_tier)\n\n\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nTierType\nA SequenceTier if a TierGroup, or a SequencePointTier if a PointsGroup\nrequired\n\n\n\n\n\n\nconcat\nmixins.tiermixins.TierGroupMixins.concat(new)\nHorizontally concatenate a tier group.\nThe two tier groups must have the same number of tiers and the same entry classes. All time values of new will be rightward shifted according to the original TierGroup or PointsGroup.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnew\nTierGroupType\nA TierGroup or PointsGroup to append.\nrequired",
    "crumbs": [
      "Tiers",
      "Common Features",
      "TierGroupMixins"
    ]
  },
  {
    "objectID": "reference/SequencePointTier.html",
    "href": "reference/SequencePointTier.html",
    "title": "SequencePointTier",
    "section": "",
    "text": "points.tiers.SequencePointTier(self, tier=[], entry_class=None)\nA SequencePointTier class\nSequencePointTiers have all the same methods and attributes as TierMixins and WithinMixins",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequencePointTier"
    ]
  },
  {
    "objectID": "reference/SequencePointTier.html#parameters",
    "href": "reference/SequencePointTier.html#parameters",
    "title": "SequencePointTier",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nlist[Point] | list[SequencePoint] | PointTier | Self\nA list of SequencePoints, or another SequencePointTier\n[]\n\n\nentry_class\nType[SequencePoint]\nA SequencePoint subclass\nNone",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequencePointTier"
    ]
  },
  {
    "objectID": "reference/SequencePointTier.html#examples",
    "href": "reference/SequencePointTier.html#examples",
    "title": "SequencePointTier",
    "section": "Examples",
    "text": "Examples\n\nfrom aligned_textgrid import SequencePoint, SequencePointTier\n\npoint_a = SequencePoint((0,\"a\"))\npoint_b = SequencePoint((1, \"b\"))\n\npoint_tier = SequencePointTier([point_a, point_b])\n\nprint(point_tier)\n\nSequence Point tier of SequencePoint;\n\n\n\nprint(point_tier.sequence_list)\n\n[Class SequencePoint, label: a; tier_index: 0, Class SequencePoint, label: b; tier_index: 1]",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequencePointTier"
    ]
  },
  {
    "objectID": "reference/SequencePointTier.html#attributes",
    "href": "reference/SequencePointTier.html#attributes",
    "title": "SequencePointTier",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nentry_class\nType[SequencePoint]\nThe class of entries within the tier\n\n\nname\nstr\nThe name of the tier\n\n\ntimes\nnp.array\nThe times of points in the tier\n\n\nlabels\nlist[str, ‚Ä¶]\nThe labels of points in the tier\n\n\nxmin\nfloat\nThe time of the first point in the tier\n\n\nxmax\nfloat\nThe time of the last point in the tier\n\n\n[]\nfloat\nIndexable and iterable",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequencePointTier"
    ]
  },
  {
    "objectID": "reference/SequencePointTier.html#methods",
    "href": "reference/SequencePointTier.html#methods",
    "title": "SequencePointTier",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nget_nearest_point\nReturns nearest point\n\n\nget_nearest_point_index\nReturns the index of the closest point to time\n\n\nreturn_tier\nReturns SequencePointTier as a praatio PointTier\n\n\nsave_as_tg\nSaves the current point tier as a textgrid\n\n\n\n\nget_nearest_point\npoints.tiers.SequencePointTier.get_nearest_point(time)\nReturns nearest point\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime at which to get the nearest point\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nSequencePoint\nthe nearest point to time\n\n\n\n\n\n\nget_nearest_point_index\npoints.tiers.SequencePointTier.get_nearest_point_index(time)\nReturns the index of the closest point to time\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\nThe time at which to get the nearest point\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the nearest point within the tier\n\n\n\n\n\n\nreturn_tier\npoints.tiers.SequencePointTier.return_tier()\nReturns SequencePointTier as a praatio PointTier\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nPointTier\nA praatio point tier\n\n\n\n\n\n\nsave_as_tg\npoints.tiers.SequencePointTier.save_as_tg(save_path)\nSaves the current point tier as a textgrid\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\npath to where you want to save the textgrid.\nrequired",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "SequencePointTier"
    ]
  },
  {
    "objectID": "reference/PointsGroup.html",
    "href": "reference/PointsGroup.html",
    "title": "PointsGroup",
    "section": "",
    "text": "points.tiers.PointsGroup(self, tiers=[SequencePointTier()])\nA collection of point tiers PointsGroups have all the same methods and attributes as TierGroupMixins and WithinMixins\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntiers\nlist[SequencePointTier]\nA list of SequencePointTiers\n[SequencePointTier()]\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_nearest_points_index\nGet indicies of nearest point\n\n\nshift\nShift the times of all points within\n\n\n\n\n\npoints.tiers.PointsGroup.get_nearest_points_index(time)\nGet indicies of nearest point\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime from which the nearest index should be returned.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of indices\n\n\n\n\n\n\n\npoints.tiers.PointsGroup.shift(increment)\nShift the times of all points within the PointsGroup by the increment size\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nincrement\nfloat\nThe time increment by which to shift the points within the PointsGroup. Could be positive or negative\nrequired",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "PointsGroup"
    ]
  },
  {
    "objectID": "reference/PointsGroup.html#parameters",
    "href": "reference/PointsGroup.html#parameters",
    "title": "PointsGroup",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntiers\nlist[SequencePointTier]\nA list of SequencePointTiers\n[SequencePointTier()]",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "PointsGroup"
    ]
  },
  {
    "objectID": "reference/PointsGroup.html#methods",
    "href": "reference/PointsGroup.html#methods",
    "title": "PointsGroup",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_nearest_points_index\nGet indicies of nearest point\n\n\nshift\nShift the times of all points within\n\n\n\n\n\npoints.tiers.PointsGroup.get_nearest_points_index(time)\nGet indicies of nearest point\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime from which the nearest index should be returned.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist\nA list of indices\n\n\n\n\n\n\n\npoints.tiers.PointsGroup.shift(increment)\nShift the times of all points within the PointsGroup by the increment size\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nincrement\nfloat\nThe time increment by which to shift the points within the PointsGroup. Could be positive or negative\nrequired",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "PointsGroup"
    ]
  },
  {
    "objectID": "reference/Top.html",
    "href": "reference/Top.html",
    "title": "Top",
    "section": "",
    "text": "Top\nsequences.sequences.Top(self)\nA top level interval class\nThis is a special subclass intended to be the superset_class for classes at the top of the hierarchy.\n\n\n\n\nReuseGPLv3",
    "crumbs": [
      "Sequence Classes",
      "Intervals",
      "Top"
    ]
  },
  {
    "objectID": "reference/Ranges.html",
    "href": "reference/Ranges.html",
    "title": "Ranges",
    "section": "",
    "text": "polar.polar_classes.Ranges(self, Interval)\nA ranges interval\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequenceInterval\n\n\nrange\nnp.array\nThe f0 range\n\n\nlow\nfloat\nThe low value of the f0 range\n\n\nhigh\nfloat\nThe high value of the f0 range\n\n\nbands\nnp.array\nThe break points in the f0 range (6 break points defining 5 bands)",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "Ranges"
    ]
  },
  {
    "objectID": "reference/Ranges.html#attributes",
    "href": "reference/Ranges.html#attributes",
    "title": "Ranges",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequenceInterval\n\n\nrange\nnp.array\nThe f0 range\n\n\nlow\nfloat\nThe low value of the f0 range\n\n\nhigh\nfloat\nThe high value of the f0 range\n\n\nbands\nnp.array\nThe break points in the f0 range (6 break points defining 5 bands)",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "Ranges"
    ]
  },
  {
    "objectID": "reference/AlignedTextGrid.html",
    "href": "reference/AlignedTextGrid.html",
    "title": "AlignedTextGrid",
    "section": "",
    "text": "aligned_textgrid.AlignedTextGrid(self, textgrid=None, entry_classes=[SequenceInterval], *, textgrid_path=None)\nAn aligned Textgrid",
    "crumbs": [
      "TextGrids",
      "AlignedTextGrid"
    ]
  },
  {
    "objectID": "reference/AlignedTextGrid.html#parameters",
    "href": "reference/AlignedTextGrid.html#parameters",
    "title": "AlignedTextGrid",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntextgrid\nstr | Path | praatio.textgrid.Textgrid\nA praatio TextGrid\nNone\n\n\nentry_classes\nSequence[Sequence[Type[SequenceInterval]]] | Sequence[Type[SequenceInterval]]\nIf a single list of SequenceInterval subclasses is given, they will be repeated as many times as necessary to assign a class to every tier. So if there are three speakers, each with a word and phone tier, [Word, Phone] will process them each into a tier group. If your TextGrids are more complex, provide a nested list with the class for each tier within each tier group. Say, if only the first speaker had both a word and phone tier, and the remaining two had only a word tier, [[Word, Phone], [Word], [Word]]\n[SequenceInterval]",
    "crumbs": [
      "TextGrids",
      "AlignedTextGrid"
    ]
  },
  {
    "objectID": "reference/AlignedTextGrid.html#attributes",
    "href": "reference/AlignedTextGrid.html#attributes",
    "title": "AlignedTextGrid",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nentry_classes\nlist[Sequence[Type[SequenceInterval]]] | list[]\nThe entry classes for each tier within a tier group.\n\n\ntier_groups\nlist[TierGroup] | list[]\nA list of TierGroup or an empty list.\n\n\ntier_names\nlist[str]\nA list of names for tiers in tier_groups.\n\n\nxmax\nfloat\nMaximum time\n\n\nxmin\nfloat\nMinimum time\n\n\n[]\n\nindexable",
    "crumbs": [
      "TextGrids",
      "AlignedTextGrid"
    ]
  },
  {
    "objectID": "reference/AlignedTextGrid.html#methods",
    "href": "reference/AlignedTextGrid.html#methods",
    "title": "AlignedTextGrid",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nappend\nAppend a new TierGroup to an existing\n\n\ncleanup\nCleanup gaps in AlignedTextGrid\n\n\nget_class_by_name\nGet an entry class by name\n\n\nget_intervals_at_time\nGet interval indices at time\n\n\ninterleave_class\nInterleave a new entry class.\n\n\npop_class\nPop a class from an AlignedTextGrid\n\n\nreturn_textgrid\nConvert this AlignedTextGrid to a praatio Textgrid\n\n\nsave_textgrid\nSaves the current AlignedTextGrid\n\n\nshift\nShift all times (interval starts & ends and point times)\n\n\n\n\nappend\naligned_textgrid.AlignedTextGrid.append(tier_group)\nAppend a new TierGroup to an existing AlignedTextGrid.\n\nExamples\n\nfrom aligned_textgrid import Word, Phone, SequenceTier, TierGroup, AlignedTextGrid\n\nspeaker1 = TierGroup([\n    SequenceTier([\n        Word((0,10, \"Hi\"))\n    ]),\n    SequenceTier([\n        Phone((0,5, \"HH\")),\n        Phone((5,10, \"AY\"))\n    ])\n])\n\nspeaker2 = TierGroup([\n    SequenceTier([\n        Word((10,20, \"Hi\"))\n    ]),\n    SequenceTier([\n        Phone((10,15, \"HH\")),\n        Phone((15,20, \"AY\"))\n    ])\n])\n\natg = AlignedTextGrid()\n\natg.append(speaker1)\natg.append(speaker2)\n\nprint(atg)\n\nAlignedTextGrid with 2 groups named [None, None] each with [2, 2] tiers. [['Word', 'Phone'], ['Word', 'Phone']]\n\n\n\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier_group\nTierGroup\nThe TierGroup to append to the AlignedTextGrid\nrequired\n\n\n\n\n\n\ncleanup\naligned_textgrid.AlignedTextGrid.cleanup()\nCleanup gaps in AlignedTextGrid\nIf any tiers have time gaps between intervals, missing subset or superset intervals or TierGroups with different start and ent times, this will clean them up by adding intervals with a blank label.\n\n\nget_class_by_name\naligned_textgrid.AlignedTextGrid.get_class_by_name(class_name)\nGet an entry class by name\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclass_name\nstr\nThe requested entry class\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval | list[SequenceInterval] | None\nThe requested entry class(es), if any\n\n\n\n\n\n\nget_intervals_at_time\naligned_textgrid.AlignedTextGrid.get_intervals_at_time(time)\nGet interval indices at time\nReturns a nested list of intervals at time for each tier.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nlist[list[int]]\na nested list of interval indices.\n\n\n\n\n\n\ninterleave_class\naligned_textgrid.AlignedTextGrid.interleave_class(name, above=None, below=None, timing_from='below', copy_labels=True)\nInterleave a new entry class.\nYou can set either above or below, but not both.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nName of the new class\nrequired\n\n\nabove\nType[SequenceInterval] | str\nWhich entry class to interleave above.\nNone\n\n\nbelow\nType[SequenceInterval] | str\nWhich entry class to interleave below.\nNone\n\n\ntiming_from\nLiteral[‚Äòabove‚Äô, ‚Äòbelow‚Äô]\nWhich tier to draw timing from. Defaults to ‚Äúbelow‚Äù.\n'below'\n\n\ncopy_labels\nbool\nWhether or not to copy labels from the tier providing timing information. Defaults to True.\nTrue\n\n\n\n\n\nExamples\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone\n\natg = AlignedTextGrid(\n    textgrid_path = \"../usage/resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes = [Word, Phone]\n)\nprint(atg)\n\nAlignedTextGrid with 1 groups named ['group_0'] each with [2] tiers. [['Word', 'Phone']]\n\n\n\natg.interleave_class(\n    name = \"Syllable\",\n    above = \"Phone\",\n    timing_from = \"below\",\n    copy_labels = True\n)\nprint(atg)\n\nAlignedTextGrid with 1 groups named ['group_0'] each with [3] tiers. [['Word', 'Syllable', 'Phone']]\n\n\n\n\n\npop_class\naligned_textgrid.AlignedTextGrid.pop_class(name)\nPop a class from an AlignedTextGrid\nRemove a class of tiers from an AlignedTextGrid\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nType[SequenceInterval] | str\nThe tier class to remove.\nrequired\n\n\n\n\n\nExamples\n\nfrom aligned_textgrid import AlignedTextGrid, custom_classes\n\natg = AlignedTextGrid(\n    textgrid_path = \"../usage/resources/spritely.TextGrid\",\n    entry_classes = custom_classes([\n        \"PrWord\",\n        \"Foot\",\n        \"Syl\",\n        \"OnsetRime\",\n        \"SylPart\",\n        \"Phone\"\n    ])\n)\nprint(atg)\n\nAlignedTextGrid with 1 groups named ['group_0'] each with [6] tiers. [['PrWord', 'Foot', 'Syl', 'OnsetRime', 'SylPart', 'Phone']]\n\n\n\natg.pop_class(\"SylPart\")\nprint(atg)\n\nAlignedTextGrid with 1 groups named ['group_0'] each with [5] tiers. [['PrWord', 'Foot', 'Syl', 'OnsetRime', 'Phone']]\n\n\n\n\n\nreturn_textgrid\naligned_textgrid.AlignedTextGrid.return_textgrid()\nConvert this AlignedTextGrid to a praatio Textgrid\nReturns the current object as a praatio.data_classes.textgrid.Textgrid. Useful for saving.\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.data_classes.textgrid.Textgrid\nA praatio Textgrid\n\n\n\n\n\n\nsave_textgrid\naligned_textgrid.AlignedTextGrid.save_textgrid(save_path, format='long_textgrid')\nSaves the current AlignedTextGrid\nUses the praatio.data_classes.textgrid.Textgrid.save() method.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\npath for saving the textgrid\nrequired\n\n\nformat\nLiteral[‚Äòshort_textgrid‚Äô, ‚Äòlong_textgrid‚Äô, ‚Äòjson‚Äô, ‚Äòtextgrid_json‚Äô]\nSave format.\n'long_textgrid'\n\n\n\n\n\n\nshift\naligned_textgrid.AlignedTextGrid.shift(increment)\nShift all times (interval starts & ends and point times) by the given increment.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nincrement\nfloat\nThe increment by which to shift all times. Could be positive or negative.\nrequired",
    "crumbs": [
      "TextGrids",
      "AlignedTextGrid"
    ]
  },
  {
    "objectID": "reference/Phone.html",
    "href": "reference/Phone.html",
    "title": "Phone",
    "section": "",
    "text": "sequences.word_and_phone.Phone(self, interval=(None, None, None), *, Interval=None)\nA Phone subclass of SequenceInterval\nHas all the same methods and attributes as SequenceInterval in addition to attributes described below. superset_class set to Word, and subset_class set to Bottom",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Phone"
    ]
  },
  {
    "objectID": "reference/Phone.html#parameters",
    "href": "reference/Phone.html#parameters",
    "title": "Phone",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninterval\nlist | tuple | Interval | SequenceInterval\nA tuple or list of start, end and label, or another SequenceInterval\n(None, None, None)",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Phone"
    ]
  },
  {
    "objectID": "reference/Phone.html#examples",
    "href": "reference/Phone.html#examples",
    "title": "Phone",
    "section": "Examples",
    "text": "Examples\n\nfrom aligned_textgrid import Word, Phone\n\nDH = Phone((0, 1, \"DH\"))\nAH0 = Phone((1, 2, \"AH0\"))\n\nTHE = Word((0, 2, \"THE\"))\n\nDH.set_word(THE)\nAH0.set_word(THE)\n\nprint(\n    (\n    f\"The phone is {DH.label}. \"\n    f\"The next phone is {DH.fol.label}. \"\n    f\"It is in the word {DH.inword.label}.\"\n    )\n)\n\nThe phone is DH. The next phone is AH0. It is in the word THE.",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Phone"
    ]
  },
  {
    "objectID": "reference/Phone.html#attributes",
    "href": "reference/Phone.html#attributes",
    "title": "Phone",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\ninword\nWord\nThe word instance this phone appears in.",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Phone"
    ]
  },
  {
    "objectID": "reference/Phone.html#methods",
    "href": "reference/Phone.html#methods",
    "title": "Phone",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nset_word\nConvenience function to set word for this Phone\n\n\n\n\nset_word\nsequences.word_and_phone.Phone.set_word(word)\nConvenience function to set word for this Phone\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nword\nWord\nWord instance.\nrequired",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Phone"
    ]
  },
  {
    "objectID": "reference/Bottom.html",
    "href": "reference/Bottom.html",
    "title": "Bottom",
    "section": "",
    "text": "Bottom\nsequences.sequences.Bottom(self)\nA bottom level interval class\nThis is a special subclass intended to be the subset_class for classes at the bottom of the hierarchy.\n\n\n\n\nReuseGPLv3",
    "crumbs": [
      "Sequence Classes",
      "Intervals",
      "Bottom"
    ]
  },
  {
    "objectID": "reference/TierGroup.html",
    "href": "reference/TierGroup.html",
    "title": "TierGroup",
    "section": "",
    "text": "sequences.tiers.TierGroup(self, tiers=[SequenceTier()])\nTier Grouping\nPointsGroups have all the same methods and attributes as TierGroupMixins and WithinMixins\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntiers\nlist[SequenceTier]\nA list of sequence tiers that are meant to be in hierarchical relationships with eachother\n[SequenceTier()]\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntier_list\nlist[SequenceTier]\nList of sequence tiers that have been related.\n\n\nentry_classes\nlist[Type[SequenceInterval]]\nA list of the entry classes for each tier.\n\n\ntier_names\nlist[str]\nA list of tier names\n\n\nxmax\nfloat\nMaximum time\n\n\nxmin\nfloat\nMinimum time\n\n\n[]\n\nIndexable. Returns a SequenceTier\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncleanup\nThis will fill any gaps between intervals with intervals\n\n\nget_intervals_at_time\nGet intervals at time\n\n\nshift\nShift the start and end times of all intervals within\n\n\nshow_structure\nShow the hierarchical structure\n\n\n\n\n\nsequences.tiers.TierGroup.cleanup()\nThis will fill any gaps between intervals with intervals with an empty label.\n\n\n\nsequences.tiers.TierGroup.get_intervals_at_time(time)\nGet intervals at time\nReturns a list of intervals at time for each tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\nTime in intervals\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[int]\nA list of interval indices, one for each tier in tier_list\n\n\n\n\n\n\n\nsequences.tiers.TierGroup.shift(increment)\nShift the start and end times of all intervals within the TierGroup by the increment size\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nincrement\nfloat\nThe time increment by which to shift the intervals within the TierGroup. Could be positive or negative\nrequired\n\n\n\n\n\n\n\nsequences.tiers.TierGroup.show_structure()\nShow the hierarchical structure",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "TierGroup"
    ]
  },
  {
    "objectID": "reference/TierGroup.html#parameters",
    "href": "reference/TierGroup.html#parameters",
    "title": "TierGroup",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntiers\nlist[SequenceTier]\nA list of sequence tiers that are meant to be in hierarchical relationships with eachother\n[SequenceTier()]",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "TierGroup"
    ]
  },
  {
    "objectID": "reference/TierGroup.html#attributes",
    "href": "reference/TierGroup.html#attributes",
    "title": "TierGroup",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntier_list\nlist[SequenceTier]\nList of sequence tiers that have been related.\n\n\nentry_classes\nlist[Type[SequenceInterval]]\nA list of the entry classes for each tier.\n\n\ntier_names\nlist[str]\nA list of tier names\n\n\nxmax\nfloat\nMaximum time\n\n\nxmin\nfloat\nMinimum time\n\n\n[]\n\nIndexable. Returns a SequenceTier",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "TierGroup"
    ]
  },
  {
    "objectID": "reference/TierGroup.html#methods",
    "href": "reference/TierGroup.html#methods",
    "title": "TierGroup",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncleanup\nThis will fill any gaps between intervals with intervals\n\n\nget_intervals_at_time\nGet intervals at time\n\n\nshift\nShift the start and end times of all intervals within\n\n\nshow_structure\nShow the hierarchical structure\n\n\n\n\n\nsequences.tiers.TierGroup.cleanup()\nThis will fill any gaps between intervals with intervals with an empty label.\n\n\n\nsequences.tiers.TierGroup.get_intervals_at_time(time)\nGet intervals at time\nReturns a list of intervals at time for each tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\nTime in intervals\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[int]\nA list of interval indices, one for each tier in tier_list\n\n\n\n\n\n\n\nsequences.tiers.TierGroup.shift(increment)\nShift the start and end times of all intervals within the TierGroup by the increment size\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nincrement\nfloat\nThe time increment by which to shift the intervals within the TierGroup. Could be positive or negative\nrequired\n\n\n\n\n\n\n\nsequences.tiers.TierGroup.show_structure()\nShow the hierarchical structure",
    "crumbs": [
      "Tiers",
      "Tiers and Tier Groups",
      "TierGroup"
    ]
  },
  {
    "objectID": "reference/custom_classes.clone_class.html",
    "href": "reference/custom_classes.clone_class.html",
    "title": "custom_classes.clone_class",
    "section": "",
    "text": "custom_classes.clone_class(entry_class, recurse=False)\nClone an entry class. It will have the same name, but any changes to its class properties will not be reflected in the original class.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry_class\nSequenceInterval | SequencePoint\nA SequenceInterval or SequencePoint to clone\nrequired\n\n\nrecurse\nbool\nUsed internally to clone the entire hierarchy. Defaults to False.\nFalse\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval | SequencePoint\nA cloned entry class",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes.clone_class"
    ]
  },
  {
    "objectID": "reference/custom_classes.clone_class.html#parameters",
    "href": "reference/custom_classes.clone_class.html#parameters",
    "title": "custom_classes.clone_class",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nentry_class\nSequenceInterval | SequencePoint\nA SequenceInterval or SequencePoint to clone\nrequired\n\n\nrecurse\nbool\nUsed internally to clone the entire hierarchy. Defaults to False.\nFalse",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes.clone_class"
    ]
  },
  {
    "objectID": "reference/custom_classes.clone_class.html#returns",
    "href": "reference/custom_classes.clone_class.html#returns",
    "title": "custom_classes.clone_class",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nSequenceInterval | SequencePoint\nA cloned entry class",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes.clone_class"
    ]
  },
  {
    "objectID": "reference/custom_classes.get_class_hierarchy.html",
    "href": "reference/custom_classes.get_class_hierarchy.html",
    "title": "custom_classes.get_class_hierarchy",
    "section": "",
    "text": "custom_classes.get_class_hierarchy(entry_class, out_list=[])\nGiven a SequenceInterval, this will return the entire class hierarchy\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry_class\nSequenceInterval\nEntry class to search the hierarchy for\nrequired\n\n\nout_list\nlist\nUsed internally for recursive search. Defaults to [].\n[]\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[SequenceInterval]\nThe class hierarchy",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes.get_class_hierarchy"
    ]
  },
  {
    "objectID": "reference/custom_classes.get_class_hierarchy.html#parameters",
    "href": "reference/custom_classes.get_class_hierarchy.html#parameters",
    "title": "custom_classes.get_class_hierarchy",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nentry_class\nSequenceInterval\nEntry class to search the hierarchy for\nrequired\n\n\nout_list\nlist\nUsed internally for recursive search. Defaults to [].\n[]",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes.get_class_hierarchy"
    ]
  },
  {
    "objectID": "reference/custom_classes.get_class_hierarchy.html#returns",
    "href": "reference/custom_classes.get_class_hierarchy.html#returns",
    "title": "custom_classes.get_class_hierarchy",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nlist[SequenceInterval]\nThe class hierarchy",
    "crumbs": [
      "Custom Classes",
      "Custom Class Creation",
      "custom_classes.get_class_hierarchy"
    ]
  },
  {
    "objectID": "reference/WithinMixins.html",
    "href": "reference/WithinMixins.html",
    "title": "WithinMixins",
    "section": "",
    "text": "mixins.within.WithinMixins()\nA collection of attributes defining within and contains realtions\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nwithin\nWithin\nThe object that the current object is within.\n\n\ncontains\nSequence[Contained]\nA list of objects that the current objects contains\n\n\nwithin_index\nint\nThe current object‚Äôs index within its‚Äô within object.\n\n\nwithin_path\nint\nThe path of indices from the uppermost container to the current object\n\n\nid\nstr\nAn id derived from the within_path.",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "WithinMixins"
    ]
  },
  {
    "objectID": "reference/WithinMixins.html#attributes",
    "href": "reference/WithinMixins.html#attributes",
    "title": "WithinMixins",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nwithin\nWithin\nThe object that the current object is within.\n\n\ncontains\nSequence[Contained]\nA list of objects that the current objects contains\n\n\nwithin_index\nint\nThe current object‚Äôs index within its‚Äô within object.\n\n\nwithin_path\nint\nThe path of indices from the uppermost container to the current object\n\n\nid\nstr\nAn id derived from the within_path.",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "WithinMixins"
    ]
  },
  {
    "objectID": "reference/TurningPoints.html",
    "href": "reference/TurningPoints.html",
    "title": "TurningPoints",
    "section": "",
    "text": "polar.polar_classes.TurningPoints(self, Point)\nA turning point class\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint\n\n\nlevel\nLevels\nThe Levels point associated with this turning point\n\n\ncertainty\nstr\nIf a ‚Äò?‚Äô was appended to a point label, 'uncertain', otherwise 'certain'\n\n\noverride\nstr\nAn override value, if provided",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "TurningPoints"
    ]
  },
  {
    "objectID": "reference/TurningPoints.html#attributes",
    "href": "reference/TurningPoints.html#attributes",
    "title": "TurningPoints",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint\n\n\nlevel\nLevels\nThe Levels point associated with this turning point\n\n\ncertainty\nstr\nIf a ‚Äò?‚Äô was appended to a point label, 'uncertain', otherwise 'certain'\n\n\noverride\nstr\nAn override value, if provided",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "TurningPoints"
    ]
  },
  {
    "objectID": "reference/Word.html",
    "href": "reference/Word.html",
    "title": "Word",
    "section": "",
    "text": "sequences.word_and_phone.Word(self, interval=(None, None, None), *, Interval=None)\nA Word subclass of SequenceInterval\nHas all the same methods and attributes as SequenceInterval in addition to attributes described below.\nsuperset_class set to Top, and subset_class set to Phone",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Word"
    ]
  },
  {
    "objectID": "reference/Word.html#parameters",
    "href": "reference/Word.html#parameters",
    "title": "Word",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninterval\nlist | tuple | Interval | SequenceInterval\nA tuple or list of start, end and label, or another SequenceInterval\n(None, None, None)",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Word"
    ]
  },
  {
    "objectID": "reference/Word.html#examples",
    "href": "reference/Word.html#examples",
    "title": "Word",
    "section": "Examples",
    "text": "Examples\n\nfrom aligned_textgrid import Word, Phone\n\nDH = Phone((0, 1, \"DH\"))\nAH0 = Phone((1, 2, \"AH0\"))\n\nTHE = Word((0, 2, \"THE\"))\n\nTHE.set_phones([DH, AH0])\n\nprint(THE.phones)\n\n['DH', 'AH0']",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Word"
    ]
  },
  {
    "objectID": "reference/Word.html#attributes",
    "href": "reference/Word.html#attributes",
    "title": "Word",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\nphone_list\nlist[Phone]\nA list of Phone objects\n\n\nphones\nlist[str]\nA list of phone labels",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Word"
    ]
  },
  {
    "objectID": "reference/Word.html#methods",
    "href": "reference/Word.html#methods",
    "title": "Word",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nset_phones\nConvenience function to set the phones\n\n\n\n\nset_phones\nsequences.word_and_phone.Word.set_phones(phone_list)\nConvenience function to set the phones\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nphone_list\nlist[Phone]\nList of Phone instances\nrequired",
    "crumbs": [
      "Custom Classes",
      "Word and Phone Classes",
      "Word"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "These classes define attributes and methods for Intervals and Points.\n\n\nThese classes define common attributes and methods available to intervals and points.\n\n\n\nWithinMixins\nA collection of attributes defining within and contains realtions\n\n\nPrecedenceMixins\nMethods and attributes for SequenceIntervals and SequencePoints\n\n\nInTierMixins\nMethods and attrubites relating Sequence* objects to tiers.\n\n\n\n\n\n\nThe basic SequenceInterval class and special Top and Bottom classes. For customized SequenceIntervals, see Word and Phone, or custom_classes().\n\n\n\nSequenceInterval\nA class to describe an interval with precedence relationships and hierarchical relationships\n\n\nTop\nA top level interval class\n\n\nBottom\nA bottom level interval class\n\n\n\n\n\n\nThere is just a single SequencePoint class, since points don‚Äôt have hierarchical relationships defined.\n\n\n\nSequencePoint\nSequence Points\n\n\n\n\n\n\n\n\n\n\nSequenceList\nA list of SequenceIntervals or SequencePoints that\n\n\n\n\n\n\nTiers Classes\n\n\nThese classes define common attributes and methods shared accross all tier and tiergroups.\n\n\n\nTierMixins\nMethods and attributes for Sequence Tiers\n\n\nTierGroupMixins\nMethods and attributes for grouped tiers\n\n\n\n\n\n\nThese classes define tiers and tier groups.\n\n\n\nSequenceTier\nA sequence tier\n\n\nSequencePointTier\nA SequencePointTier class\n\n\nTierGroup\nTier Grouping\n\n\nPointsGroup\nA collection of point tiers\n\n\n\n\n\n\n\nTextGrid Classes\n\n\n\nAlignedTextGrid\nAn aligned Textgrid\n\n\n\n\n\n\nCustom Classes\n\n\nThis is a function that will quickly create custom classes\n\n\n\ncustom_classes\nGenerate custom interval classes\n\n\ncustom_classes.clone_class\nClone an entry class. It will have the same name, but\n\n\ncustom_classes.get_class_hierarchy\nGiven a SequenceInterval, this will return\n\n\n\n\n\n\nThese are mostly intended to be used with textgrids that are the product of forced alignment.\n\n\n\nWord\nA Word subclass of SequenceInterval\n\n\nPhone\nA Phone subclass of SequenceInterval\n\n\n\n\n\n\nThese are classes intended to make it easier to work with PoLaR annotation.\n\n\n\nPrStr\nPrStr tier points\n\n\nToBI\nA ToBI point class\n\n\nToBI\nA ToBI point class\n\n\nTurningPoints\nA turning point class\n\n\nRanges\nA ranges interval\n\n\nLevels\nA levels point class\n\n\nMisc\nMisc points\n\n\n\n\n\n\n\nThis will return a polars dataframe given an aligned_textgrid object\n\n\n\nto_df\nReturn an aligned_textgrid object as a dataframe",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#sequence-classes",
    "href": "reference/index.html#sequence-classes",
    "title": "Function reference",
    "section": "",
    "text": "These classes define attributes and methods for Intervals and Points.\n\n\nThese classes define common attributes and methods available to intervals and points.\n\n\n\nWithinMixins\nA collection of attributes defining within and contains realtions\n\n\nPrecedenceMixins\nMethods and attributes for SequenceIntervals and SequencePoints\n\n\nInTierMixins\nMethods and attrubites relating Sequence* objects to tiers.\n\n\n\n\n\n\nThe basic SequenceInterval class and special Top and Bottom classes. For customized SequenceIntervals, see Word and Phone, or custom_classes().\n\n\n\nSequenceInterval\nA class to describe an interval with precedence relationships and hierarchical relationships\n\n\nTop\nA top level interval class\n\n\nBottom\nA bottom level interval class\n\n\n\n\n\n\nThere is just a single SequencePoint class, since points don‚Äôt have hierarchical relationships defined.\n\n\n\nSequencePoint\nSequence Points",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#sequencelist",
    "href": "reference/index.html#sequencelist",
    "title": "Function reference",
    "section": "",
    "text": "SequenceList\nA list of SequenceIntervals or SequencePoints that",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#tiers",
    "href": "reference/index.html#tiers",
    "title": "Function reference",
    "section": "",
    "text": "Tiers Classes\n\n\nThese classes define common attributes and methods shared accross all tier and tiergroups.\n\n\n\nTierMixins\nMethods and attributes for Sequence Tiers\n\n\nTierGroupMixins\nMethods and attributes for grouped tiers\n\n\n\n\n\n\nThese classes define tiers and tier groups.\n\n\n\nSequenceTier\nA sequence tier\n\n\nSequencePointTier\nA SequencePointTier class\n\n\nTierGroup\nTier Grouping\n\n\nPointsGroup\nA collection of point tiers",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#textgrids",
    "href": "reference/index.html#textgrids",
    "title": "Function reference",
    "section": "",
    "text": "TextGrid Classes\n\n\n\nAlignedTextGrid\nAn aligned Textgrid",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#custom-classes",
    "href": "reference/index.html#custom-classes",
    "title": "Function reference",
    "section": "",
    "text": "Custom Classes\n\n\nThis is a function that will quickly create custom classes\n\n\n\ncustom_classes\nGenerate custom interval classes\n\n\ncustom_classes.clone_class\nClone an entry class. It will have the same name, but\n\n\ncustom_classes.get_class_hierarchy\nGiven a SequenceInterval, this will return\n\n\n\n\n\n\nThese are mostly intended to be used with textgrids that are the product of forced alignment.\n\n\n\nWord\nA Word subclass of SequenceInterval\n\n\nPhone\nA Phone subclass of SequenceInterval\n\n\n\n\n\n\nThese are classes intended to make it easier to work with PoLaR annotation.\n\n\n\nPrStr\nPrStr tier points\n\n\nToBI\nA ToBI point class\n\n\nToBI\nA ToBI point class\n\n\nTurningPoints\nA turning point class\n\n\nRanges\nA ranges interval\n\n\nLevels\nA levels point class\n\n\nMisc\nMisc points",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/index.html#dataframe-outputs",
    "href": "reference/index.html#dataframe-outputs",
    "title": "Function reference",
    "section": "",
    "text": "This will return a polars dataframe given an aligned_textgrid object\n\n\n\nto_df\nReturn an aligned_textgrid object as a dataframe",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "reference/PrecedenceMixins.html",
    "href": "reference/PrecedenceMixins.html",
    "title": "PrecedenceMixins",
    "section": "",
    "text": "mixins.mixins.PrecedenceMixins()\nMethods and attributes for SequenceIntervals and SequencePoints\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfirst\nSequenceInterval\nThe first interval in the subset list\n\n\nlast\nSequenceInterval\nThe last interval in the subset list\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_final\nSets the current object as having no fol entry\n\n\nset_fol\nSets the following instance\n\n\nset_initial\nSets the current object as having no prev entry\n\n\nset_prev\nSets the previous intance\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_final()\nSets the current object as having no fol entry\nWhile self.fol is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_fol(next_int)\nSets the following instance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnext_int\nSequenceInterval | SequencePoint\nSets the next_int as the fol entry. Must be of the same class as the current object. That is, type(next_int) is type(self)\nrequired\n\n\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_initial()\nSets the current object as having no prev entry\nWhile self.prev is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_prev(prev_int)\nSets the previous intance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprev_int\nSequenceInterval | SequencePoint\nSets the prev_int as the prev entry. Must be of the same class as the current object. That is, type(prev_int) is type(self)\nrequired",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "PrecedenceMixins"
    ]
  },
  {
    "objectID": "reference/PrecedenceMixins.html#attributes",
    "href": "reference/PrecedenceMixins.html#attributes",
    "title": "PrecedenceMixins",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nfirst\nSequenceInterval\nThe first interval in the subset list\n\n\nlast\nSequenceInterval\nThe last interval in the subset list",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "PrecedenceMixins"
    ]
  },
  {
    "objectID": "reference/PrecedenceMixins.html#methods",
    "href": "reference/PrecedenceMixins.html#methods",
    "title": "PrecedenceMixins",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_final\nSets the current object as having no fol entry\n\n\nset_fol\nSets the following instance\n\n\nset_initial\nSets the current object as having no prev entry\n\n\nset_prev\nSets the previous intance\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_final()\nSets the current object as having no fol entry\nWhile self.fol is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_fol(next_int)\nSets the following instance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnext_int\nSequenceInterval | SequencePoint\nSets the next_int as the fol entry. Must be of the same class as the current object. That is, type(next_int) is type(self)\nrequired\n\n\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_initial()\nSets the current object as having no prev entry\nWhile self.prev is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_prev(prev_int)\nSets the previous intance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprev_int\nSequenceInterval | SequencePoint\nSets the prev_int as the prev entry. Must be of the same class as the current object. That is, type(prev_int) is type(self)\nrequired",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "PrecedenceMixins"
    ]
  },
  {
    "objectID": "reference/to_df.html",
    "href": "reference/to_df.html",
    "title": "to_df",
    "section": "",
    "text": "outputs.to_dataframe.to_df(obj, with_subset=True)\nReturn an aligned_textgrid object as a dataframe\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nobj\nSequenceInterval | SequencePoint | SequenceTier | SequencePointTier | TierGroup | PointsGroup | AlignedTextGrid\nAn aligned_textgrid object\nrequired\n\n\nwith_subset\nbool\nWhether or not to include subset relationships. Defaults to True.\nTrue\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA polars dataframe",
    "crumbs": [
      "DataFrame outputs",
      "to_df"
    ]
  },
  {
    "objectID": "reference/to_df.html#parameters",
    "href": "reference/to_df.html#parameters",
    "title": "to_df",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nobj\nSequenceInterval | SequencePoint | SequenceTier | SequencePointTier | TierGroup | PointsGroup | AlignedTextGrid\nAn aligned_textgrid object\nrequired\n\n\nwith_subset\nbool\nWhether or not to include subset relationships. Defaults to True.\nTrue",
    "crumbs": [
      "DataFrame outputs",
      "to_df"
    ]
  },
  {
    "objectID": "reference/to_df.html#returns",
    "href": "reference/to_df.html#returns",
    "title": "to_df",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npl.DataFrame\nA polars dataframe",
    "crumbs": [
      "DataFrame outputs",
      "to_df"
    ]
  },
  {
    "objectID": "reference/InTierMixins.html",
    "href": "reference/InTierMixins.html",
    "title": "InTierMixins",
    "section": "",
    "text": "mixins.mixins.InTierMixins()\nMethods and attrubites relating Sequence* objects to tiers.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntier_index\nint\nIndex of the current entry within its tier\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_tierwise\nGet entry by relative tier index\n\n\nreturn_interval\nReturn current object as Interval\n\n\nreturn_point\nReturn current object as Point\n\n\nreturn_praatio\nReturn the correct praatio class.\n\n\n\n\n\nmixins.mixins.InTierMixins.get_tierwise(idx=0)\nGet entry by relative tier index\nReturns a SequenceInterval or SequencePoint from an index position relative to the current sequence.\n\nidx=0 - Returns the current entry\nidx=1 - Returns the following entry on the tier. If the current entry is in the final position within its subset list, this will not be the same as .fol\nidx=-1 - Returns the previous entry on the tier. If the current entry is in the initial position within its subset list, this will not be the same as .prev\n\nThis will raise an ordinary IndexError if the relative index exceeds the length of the tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nidx\nint\nThe relative tier index at which to retrieve a sequence. Defaults to 0.\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval | SequencePoint\nThe entry at the relative index\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_interval()\nReturn current object as Interval\nWill be useful for saving back to textgrid\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Interval\nA praatio Interval object\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_point()\nReturn current object as Point\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Point\nA praatio Point\n\n\nPoint\nobject\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_praatio()\nReturn the correct praatio class.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInterval | Point\nA praatio Interval or Point.",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "InTierMixins"
    ]
  },
  {
    "objectID": "reference/InTierMixins.html#attributes",
    "href": "reference/InTierMixins.html#attributes",
    "title": "InTierMixins",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntier_index\nint\nIndex of the current entry within its tier",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "InTierMixins"
    ]
  },
  {
    "objectID": "reference/InTierMixins.html#methods",
    "href": "reference/InTierMixins.html#methods",
    "title": "InTierMixins",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_tierwise\nGet entry by relative tier index\n\n\nreturn_interval\nReturn current object as Interval\n\n\nreturn_point\nReturn current object as Point\n\n\nreturn_praatio\nReturn the correct praatio class.\n\n\n\n\n\nmixins.mixins.InTierMixins.get_tierwise(idx=0)\nGet entry by relative tier index\nReturns a SequenceInterval or SequencePoint from an index position relative to the current sequence.\n\nidx=0 - Returns the current entry\nidx=1 - Returns the following entry on the tier. If the current entry is in the final position within its subset list, this will not be the same as .fol\nidx=-1 - Returns the previous entry on the tier. If the current entry is in the initial position within its subset list, this will not be the same as .prev\n\nThis will raise an ordinary IndexError if the relative index exceeds the length of the tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nidx\nint\nThe relative tier index at which to retrieve a sequence. Defaults to 0.\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval | SequencePoint\nThe entry at the relative index\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_interval()\nReturn current object as Interval\nWill be useful for saving back to textgrid\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Interval\nA praatio Interval object\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_point()\nReturn current object as Point\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Point\nA praatio Point\n\n\nPoint\nobject\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_praatio()\nReturn the correct praatio class.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nInterval | Point\nA praatio Interval or Point.",
    "crumbs": [
      "Sequence Classes",
      "Common Features",
      "InTierMixins"
    ]
  },
  {
    "objectID": "reference/PrStr.html",
    "href": "reference/PrStr.html",
    "title": "PrStr",
    "section": "",
    "text": "polar.polar_classes.PrStr(self, Point)\nPrStr tier points\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‚Äò?‚Äô was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nstatus\nstr\n'edge' or 'prominence'",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "PrStr"
    ]
  },
  {
    "objectID": "reference/PrStr.html#attributes",
    "href": "reference/PrStr.html#attributes",
    "title": "PrStr",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‚Äò?‚Äô was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nstatus\nstr\n'edge' or 'prominence'",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "PrStr"
    ]
  },
  {
    "objectID": "reference/ToBI.html",
    "href": "reference/ToBI.html",
    "title": "ToBI",
    "section": "",
    "text": "polar.polar_classes.ToBI(self, Point=None)\nA ToBI point class\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "ToBI"
    ]
  },
  {
    "objectID": "reference/ToBI.html#attributes",
    "href": "reference/ToBI.html#attributes",
    "title": "ToBI",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "ToBI"
    ]
  },
  {
    "objectID": "reference/SequencePoint.html",
    "href": "reference/SequencePoint.html",
    "title": "SequencePoint",
    "section": "",
    "text": "points.points.SequencePoint(self, point=(None, None))\nSequence Points",
    "crumbs": [
      "Sequence Classes",
      "Points",
      "SequencePoint"
    ]
  },
  {
    "objectID": "reference/SequencePoint.html#parameters",
    "href": "reference/SequencePoint.html#parameters",
    "title": "SequencePoint",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npoint\nlist | tuple | Point | Self\nA list or tuple of a time and label value.\n(None, None)",
    "crumbs": [
      "Sequence Classes",
      "Points",
      "SequencePoint"
    ]
  },
  {
    "objectID": "reference/SequencePoint.html#examples",
    "href": "reference/SequencePoint.html#examples",
    "title": "SequencePoint",
    "section": "Examples",
    "text": "Examples\n\nfrom aligned_textgrid import SequencePoint, SequenceInterval\n\nfirst_point = SequencePoint((0, \"first\"))\nprint(first_point)\n\nClass SequencePoint, label: first;\n\n\n\nsecond_point = SequencePoint((1, \"second\"))\ninterval = SequenceInterval((0.5, 2, \"word\"))\n\nprint(\n    first_point.distance_from(second_point)\n)\n\nprint(\n    first_point.distance_from(interval)\n)\n\n-1\n[-0.5 -2. ]",
    "crumbs": [
      "Sequence Classes",
      "Points",
      "SequencePoint"
    ]
  },
  {
    "objectID": "reference/SequencePoint.html#attributes",
    "href": "reference/SequencePoint.html#attributes",
    "title": "SequencePoint",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll attributes and methods included in PrecedenceMixins and InTierMixins\n\n\ntime\nfloat\nTime value associated with the point.\n\n\nlabel\nstr\nLabel associated with the point\n\n\nintier\nSequencePointTier\nIf the SequencePoint is within a tier, this accesses the tier.\n\n\nfol\nSequencePoint\nIf defined, the following SequencePoint within the same tier\n\n\nprev\nSequencePoint\nIf defined, the previous SequencePoint within the same tier.\n\n\nfol_distance\nfloat\nIf fol is defined, the difference between the current point and fol (should be &gt;= 0)\n\n\nprev_distance\nfloat\nif prev is defined, the difference between the current point and prev (should be &lt;= 0).",
    "crumbs": [
      "Sequence Classes",
      "Points",
      "SequencePoint"
    ]
  },
  {
    "objectID": "reference/SequencePoint.html#methods",
    "href": "reference/SequencePoint.html#methods",
    "title": "SequencePoint",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndistance_from\nDistance from an entry\n\n\nget_interval_at_point\nGet the SequenceInterval the current point falls within\n\n\nget_interval_index_at_time\nGet the index of an interval at the point‚Äôs time\n\n\n\n\ndistance_from\npoints.points.SequencePoint.distance_from(entry)\nDistance from an entry\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSelf | SequenceInterval\nA point or an interval to get the distance of the current point from\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nnp.array\na single value in the case of a point, a numpy array in the case of an interval.\n\n\n\n\n\n\nget_interval_at_point\npoints.points.SequencePoint.get_interval_at_point(tier=None)\nGet the SequenceInterval the current point falls within\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nSequenceTier\nThe sequence tier within which to look for a matching SequenceInterval\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval\nThe SequenceInterval within which the current point falls\n\n\n\n\n\n\nget_interval_index_at_time\npoints.points.SequencePoint.get_interval_index_at_time(tier=None)\nGet the index of an interval at the point‚Äôs time\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nSequenceTier\nA SequenceTier.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the SequenceInterval within which the point falls",
    "crumbs": [
      "Sequence Classes",
      "Points",
      "SequencePoint"
    ]
  },
  {
    "objectID": "reference/Levels.html",
    "href": "reference/Levels.html",
    "title": "Levels",
    "section": "",
    "text": "polar.polar_classes.Levels(self, Point)\nA levels point class\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‚Äò?‚Äô was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nlevel\nint\nThe level value given to this point\n\n\nband\nnp.array\nThe f0 band for this point, given its level\n\n\nranges_interval\nRanges\nThe Ranges interval this point falls within\n\n\nranges_tier\nSequenceTier\nThe Ranges tier associated with these Levels\n\n\nturning_point\nTurningPoints\nThe TurningPoints point associated with this Levels point",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "Levels"
    ]
  },
  {
    "objectID": "reference/Levels.html#attributes",
    "href": "reference/Levels.html#attributes",
    "title": "Levels",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n‚Ä¶\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‚Äò?‚Äô was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nlevel\nint\nThe level value given to this point\n\n\nband\nnp.array\nThe f0 band for this point, given its level\n\n\nranges_interval\nRanges\nThe Ranges interval this point falls within\n\n\nranges_tier\nSequenceTier\nThe Ranges tier associated with these Levels\n\n\nturning_point\nTurningPoints\nThe TurningPoints point associated with this Levels point",
    "crumbs": [
      "Custom Classes",
      "PoLaR Classes",
      "Levels"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aligned TextGrid",
    "section": "",
    "text": "The aligned-textgrid package provides a python interface for representing and operating on TextGrids produced by forced aligners like FAVE or the Montreal Forced Aligner. Classes provided by aligned-textgrid represent hierarchical and precedence relationships among data stored in TextGrid formats allowing for simplified and more accessible analysis of aligned speech data.",
    "crumbs": [
      "Get Started",
      "Getting Started",
      "Aligned TextGrid"
    ]
  },
  {
    "objectID": "index.html#example-use-cases",
    "href": "index.html#example-use-cases",
    "title": "Aligned TextGrid",
    "section": "Example Use Cases",
    "text": "Example Use Cases\n\nYou want to quickly loop through the Phone tier of a Textgrid, and also access information about the word it is a part of.\nYou want to quickly loop over the Word tier of a Textgrid and quickly count how many phones it has.\nYou want to programmatically merge together adjacent Textgrid intervals.\n\nFor examples on how to use the pacakge, see the Usage pages.",
    "crumbs": [
      "Get Started",
      "Getting Started",
      "Aligned TextGrid"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Aligned TextGrid",
    "section": "Installation",
    "text": "Installation\n\nTo install aligned-textgrid using pip, run the following command in your terminal:\npip install aligned-textgrid",
    "crumbs": [
      "Get Started",
      "Getting Started",
      "Aligned TextGrid"
    ]
  },
  {
    "objectID": "index.html#not-another-textgrid-implementation",
    "href": "index.html#not-another-textgrid-implementation",
    "title": "Aligned TextGrid",
    "section": "Not another TextGrid implementation",
    "text": "Not another TextGrid implementation\nThere are several other packages that parse Praat Textgrids, including\n\npraatio\ntextgrid\n\naligned-textgrid‚Äôs goal is to capture hierarchical and sequential relationships represented in many TextGrids, and to make them easilly accessible to users via an intuitive interface. The goal is that from any arbitrary location within a TextGrid, users can easilly access information with minimally defensive coding.\n\n\nExample\nAs an example, we‚Äôll read in a textgrid produced with forced alignment that contains a single speaker with a word and phone tier.\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone\ntg = AlignedTextGrid(\n    textgrid_path='usage/resources/josef-fruehwald_speaker.TextGrid', \n    entry_classes=[Word, Phone]\n    )\n\nThen, we can access an arbitrary phone interval.\n\narbitrary_interval = tg[0].Phone[20]\n\nFrom this aribitrary interval, we can access information about the intervals preceding and following with the .prev and .fol attributes.\n\nprint(arbitrary_interval.prev.label)\nprint(arbitrary_interval.label)\nprint(arbitrary_interval.fol.label)\n\nR\nEY1\nN\n\n\nWe can also access information about the word this interval is nested within with the .inword attribute.\n\nprint(arbitrary_interval.inword.label)\n\nraindrops\n\n\nThe object returned by .inword is just another interval, meaning we can access informaton about it‚Äôs context with the .prev and .fol attributes as well.\n\nprint(arbitrary_interval.inword.prev.label)\nprint(arbitrary_interval.inword.label)\nprint(arbitrary_interval.inword.fol.label)\n\nstrikes\nraindrops\nin",
    "crumbs": [
      "Get Started",
      "Getting Started",
      "Aligned TextGrid"
    ]
  },
  {
    "objectID": "index.html#for-more",
    "href": "index.html#for-more",
    "title": "Aligned TextGrid",
    "section": "For more",
    "text": "For more\n\nTo start jumping in, check out the quickstart\nTo learn more about navigating TextGrids and intervals, check out the usage pages on navigating TextGrids and navgiating sequences\nTo learn more about the attributes you can access from textgrids and sequences, see the usage pages on TextGrid attributes and interval attributes\n\nYou can also directly read up on the function and class references.",
    "crumbs": [
      "Get Started",
      "Getting Started",
      "Aligned TextGrid"
    ]
  },
  {
    "objectID": "usage/02_Sequences/00_sequence_structure.html",
    "href": "usage/02_Sequences/00_sequence_structure.html",
    "title": "Sequence Navigation",
    "section": "",
    "text": "Let‚Äôs say we began with this textgrid and read it in with AlignedTextGrid().\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\nprint(the_dog)\n\nAlignedTextGrid with 1 groups, each with [2] tiers. [['Word', 'Phone']]\nLet‚Äôs grab the objects representing the schwa in ‚Äúthe‚Äù and the the entire word ‚Äúdog‚Äù.\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\ndog = the_dog.tier_groups[0].tier_list[0].sequence_list[1]\nBoth of these objects have got basic interval information available as attributes, specifically .start, .end and .label.\n[AH0.start, AH0.end, AH0.label]\n\n[0.1827542202196579, 0.308291607646728, 'AH0']\n[dog.start, dog.end, dog.label]\n\n[0.308291607646728, 0.9665869095874072, 'dog']\nFrom within these sequence intervals, we can also access information from the precedence and hierarchical relationships.",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Navigation"
    ]
  },
  {
    "objectID": "usage/02_Sequences/00_sequence_structure.html#the-precedence-and-hierarchy-structure",
    "href": "usage/02_Sequences/00_sequence_structure.html#the-precedence-and-hierarchy-structure",
    "title": "Sequence Navigation",
    "section": "The Precedence and Hierarchy structure",
    "text": "The Precedence and Hierarchy structure\nHere is a schematic illustration of how each Sequence Interval is related to the others.\n\n\n\nSequence Structure\n\n\n\nWorking with precedence\nFor our AH0 object, we can access its preceding phone with .prev\n\nAH0.prev\n\nClass Phone, label: DH, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp\n\n\nImportantly, this is the actual preceding Sequence Interval object, so we an access all of it‚Äôs interval information like we did for AH0 itself.\n\n[AH0.prev.start, AH0.prev.end, AH0.prev.label]\n\n[0.0, 0.1827542202196579, 'DH']\n\n\nBecause AH0 is the final Sequence Interval within this word, its .fol attribute is a reference to a dummy boundary interval.\n\n[AH0.fol.start, AH0.fol.end, AH0.fol.label]\n\n[None, None, '#']\n\n\nThe dog object from the word tier has the same .prev and .fol methods available.\n\n[dog.prev.start, dog.prev.end, dog.prev.label]\n\n[0.0, 0.308291607646728, 'the']\n\n\n\n[dog.fol.start, dog.fol.end, dog.fol.label]\n\n[None, None, '#']\n\n\n\n\nUsing hierarchy\n\nMoving upwards\nYou can also navigate upwards and downwards with these objects. The most general attribute to get the Sequence Interval above is .super_instance\n\nAH0.super_instance\n\nClass Word, label: the, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['DH', 'AH0']\n\n\nHowever, the Phone class from aligned_textgrid.sequences.word_and_phone also has an .inword attribute for convenience.\n\nAH0.inword\n\nClass Word, label: the, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['DH', 'AH0']\n\n\n\n[AH0.inword.start, AH0.inword.end, AH0.inword.label]\n\n[0.0, 0.308291607646728, 'the']\n\n\n\n\nMoving Downwards\nFrom the dog object, we can navigate downwards with the .subset_list attribute, which returns a list of each phone Sequence Interval.\n\ndog.subset_list\n\n[Class Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp,\n Class Phone, label: AO1, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp,\n Class Phone, label: G, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp]\n\n\nWe can also directly index into the subset list with dog[]\n\n\n\nSequence indexing\n\n\n\ndog[2]\n\nClass Phone, label: G, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp\n\n\n\n[dog[2].start, dog[2].end, dog[2].label]\n\n[0.8356850885224085, 0.9665869095874072, 'G']\n\n\nThere are also special attributes .first and .last to access the first and last sequences within the subset list.\n\n[dog.first.label, dog.last.label]\n\n['D', 'G']\n\n\n\n\n\nMoving all around\nSince each of these attributes (.prev, .fol, .inword and .subset_list) returns the actual Sequence Interval objects, we can chain them together to create a path through the hierarchy. For example, we can see that AH0 is the final phone in its word.\n\nAH0.fol.label\n\n'#'\n\n\nTo get the label of the first phone of the following word, we can move up to .inword, over one with .fol and then index down into the subset list with .first.\n\n\n\nhierarchy path\n\n\nThere is an easier way to do this with tier references. This example is just to illustrate how a path can be constructed\n\nAH0.inword.fol.first\n\nClass Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Sequence Navigation"
    ]
  },
  {
    "objectID": "usage/02_Sequences/01_sequence-in-tier.html",
    "href": "usage/02_Sequences/01_sequence-in-tier.html",
    "title": "Navigating Sequences in a Tier",
    "section": "",
    "text": "In addition to their hierarchical relationships, sequences also have relationships to the tiers they‚Äôre in.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\ndog = the_dog.tier_groups[0].tier_list[0].sequence_list[1]",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Navigating Sequences in a Tier"
    ]
  },
  {
    "objectID": "usage/02_Sequences/01_sequence-in-tier.html#accessing-its-tier",
    "href": "usage/02_Sequences/01_sequence-in-tier.html#accessing-its-tier",
    "title": "Navigating Sequences in a Tier",
    "section": "Accessing its tier",
    "text": "Accessing its tier\nFrom a given sequence, we can access its tier with .intier\n\nAH0.intier\n\nSequence tier of Phone; .superset_class: Word; .subset_class: Bottom_wp\n\n\nWe can also get its index within that tier.\n\nAH0.tier_index\n\n1\n\n\nThis allows for tier-level operations. For example, if we wanted to find the phone interval that occurs 0.5 seconds after the end of the current sequence interval, we could do so like this:\n\nsearch_idx = AH0.intier.get_interval_at_time(AH0.end + 0.5)\nAH0.intier[search_idx]\n\nClass Phone, label: AO1, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Navigating Sequences in a Tier"
    ]
  },
  {
    "objectID": "usage/02_Sequences/01_sequence-in-tier.html#tier-wise-relationships",
    "href": "usage/02_Sequences/01_sequence-in-tier.html#tier-wise-relationships",
    "title": "Navigating Sequences in a Tier",
    "section": "Tier-wise relationships",
    "text": "Tier-wise relationships\nWhen a sequence interval is at the edge of a subset list (like, say, a phone within a word), its .fol attribute will reference a dummy boundary interval, even if there‚Äôs a following interval in its tier.\n\nAH0.fol\n\nClass Phone, label: #, .superset_class: Word, .super_instance, None, .subset_class: Bottom_wp\n\n\n\nAH0.inword.fol[0]\n\nClass Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp\n\n\nHowever, you can access intervals an arbitrary distance away, tierwise, with .get_tierwise()\n\n[AH0.get_tierwise(-1), AH0.get_tierwise(1), AH0.get_tierwise(2)]\n\n[Class Phone, label: DH, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp,\n Class Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp,\n Class Phone, label: AO1, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp]",
    "crumbs": [
      "Get Started",
      "Sequences",
      "Navigating Sequences in a Tier"
    ]
  },
  {
    "objectID": "usage/05_Outputs/01_to_dataframe.html",
    "href": "usage/05_Outputs/01_to_dataframe.html",
    "title": "Outputting and saving as a DataFrame",
    "section": "",
    "text": "You can ouput and save any given aligned_textgrid as a polars dataframe with the to_df() function.",
    "crumbs": [
      "Get Started",
      "Outputs",
      "Outputting and saving as a DataFrame"
    ]
  },
  {
    "objectID": "usage/05_Outputs/01_to_dataframe.html#outputting-as-a-data-frame",
    "href": "usage/05_Outputs/01_to_dataframe.html#outputting-as-a-data-frame",
    "title": "Outputting and saving as a DataFrame",
    "section": "Outputting as a data frame",
    "text": "Outputting as a data frame\n\nimport polars as pl\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone,\\\n                             to_df\n\ntg = AlignedTextGrid(\n    textgrid_path=\"../resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\n\n\nSingle Intervals\n\nBottom of the hierarchy\nIf you pass a single interval from the bottom of the sequence hierarchy, you‚Äôll get back a fairly minimal dataframe with the start and end times, the label, and an ID for the interval.\n\none_interval = tg[0].Phone[1]\none_interval_df = to_df(one_interval)\n\none_interval_df\n\n\nshape: (1, 5)\n\n\n\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\n\n\n\n\n\nTop of the hierarchy\nIf you pass to_df() an interval from higher up in the hierarchy, by default it will output its data, as well as the data for every interval below it in the hierarchy, concatenated horizontally.\n\nword_interval = tg[0].Word[1]\nword_interval_df = to_df(word_interval)\n\nword_interval_df\n\n\nshape: (4, 10)\n\n\n\nWord_id\nWord_tier_index\nWord_label\nWord_start\nWord_end\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-1\"\n2\n\"W\"\n1.97\n2.09\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-2\"\n3\n\"EH1\"\n2.09\n2.13\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-3\"\n4\n\"N\"\n2.13\n2.2\n\n\n\n\n\n\nHowever, if you want just a simplified, single row output for an interval, regardless of its location within the hierarchy, pass to_df(..., with_subset = False).\n\nword_interval_df2 = to_df(word_interval, with_subset=False)\n\nword_interval_df2\n\n\nshape: (1, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"Word\"\n\n\n\n\n\n\n\n\n\nTiers\nIf you pass a tier to to_df(), it will output a dataframe for ever interval in the tier concatenated vertically. By default, this means intervals high in the hierarchy will have their rows repeated for every interval they contain, but if you want one row per interval in the output, you can pass to_df(..., with_subset = False).\n\ntier_df1 = to_df(tg[0].Word)\n\ntier_df1.shape\n\n(1191, 10)\n\n\n\ntier_df1.head(10)\n\n\nshape: (10, 10)\n\n\n\nWord_id\nWord_tier_index\nWord_label\nWord_start\nWord_end\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"0-0-0-0\"\n0\n\"\"\n0.0\n0.11\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-1\"\n2\n\"W\"\n1.97\n2.09\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-2\"\n3\n\"EH1\"\n2.09\n2.13\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-3\"\n4\n\"N\"\n2.13\n2.2\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-0\"\n5\n\"DH\"\n2.2\n2.22\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-1\"\n6\n\"AH0\"\n2.22\n2.26\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-0\"\n7\n\"S\"\n2.26\n2.39\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-1\"\n8\n\"AH1\"\n2.39\n2.44\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-2\"\n9\n\"N\"\n2.44\n2.52\n\n\n\n\n\n\n\n# 1 row per interval\ntier_df2 = to_df(tg[0].Word, with_subset=False)\n\ntier_df2.shape\n\n(377, 6)\n\n\n\ntier_df2.head(10)\n\n\nshape: (10, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"Word\"\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"Word\"\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"Word\"\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"Word\"\n\n\n\"0-0-4\"\n4\n\"strikes\"\n2.72\n3.22\n\"Word\"\n\n\n\"0-0-5\"\n5\n\"raindrops\"\n3.22\n3.79\n\"Word\"\n\n\n\"0-0-6\"\n6\n\"in\"\n3.79\n3.89\n\"Word\"\n\n\n\"0-0-7\"\n7\n\"the\"\n3.89\n4.02\n\"Word\"\n\n\n\"0-0-8\"\n8\n\"air\"\n4.02\n4.45\n\"Word\"\n\n\n\"0-0-9\"\n9\n\"\"\n4.45\n4.61\n\"Word\"\n\n\n\n\n\n\n\n\nTierGroups and TextGrids\nThe behavior for TierGroups and TextGrids are similar. By default, the to_df() function will either return a dataframe representing the entire hierarchy structure, or will return one row for each interval in the TextGrid.\n\nfull_df1 = to_df(tg)\n\nfull_df1.shape\n\n(1191, 10)\n\n\n\nfull_df1.head(10)\n\n\nshape: (10, 10)\n\n\n\nWord_id\nWord_tier_index\nWord_label\nWord_start\nWord_end\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"0-0-0-0\"\n0\n\"\"\n0.0\n0.11\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-1\"\n2\n\"W\"\n1.97\n2.09\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-2\"\n3\n\"EH1\"\n2.09\n2.13\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-3\"\n4\n\"N\"\n2.13\n2.2\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-0\"\n5\n\"DH\"\n2.2\n2.22\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-1\"\n6\n\"AH0\"\n2.22\n2.26\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-0\"\n7\n\"S\"\n2.26\n2.39\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-1\"\n8\n\"AH1\"\n2.39\n2.44\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-2\"\n9\n\"N\"\n2.44\n2.52\n\n\n\n\n\n\n\n# 1 row per interval\nfull_df2 = to_df(tg, with_subset=False)\n\nfull_df2.shape\n\n(1568, 6)\n\n\n\nfull_df2.head(5)\n\n\nshape: (5, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"Word\"\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"Word\"\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"Word\"\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"Word\"\n\n\n\"0-0-4\"\n4\n\"strikes\"\n2.72\n3.22\n\"Word\"\n\n\n\n\n\n\n\nfull_df2.tail(5)\n\n\nshape: (5, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-374-1\"\n1186\n\"R\"\n111.83\n111.92\n\"Phone\"\n\n\n\"0-0-375-0\"\n1187\n\"B\"\n111.92\n112.02\n\"Phone\"\n\n\n\"0-0-375-1\"\n1188\n\"L\"\n112.02\n112.08\n\"Phone\"\n\n\n\"0-0-375-2\"\n1189\n\"UW1\"\n112.08\n112.31\n\"Phone\"\n\n\n\"0-0-376-0\"\n1190\n\"\"\n112.31\n115.065034\n\"Phone\"",
    "crumbs": [
      "Get Started",
      "Outputs",
      "Outputting and saving as a DataFrame"
    ]
  },
  {
    "objectID": "usage/05_Outputs/01_to_dataframe.html#saving-a-dataframe",
    "href": "usage/05_Outputs/01_to_dataframe.html#saving-a-dataframe",
    "title": "Outputting and saving as a DataFrame",
    "section": "Saving a DataFrame",
    "text": "Saving a DataFrame\nTo save one of these dataframes, use one of the methods from polars, like DataFrame.write_csv()\n\nfull_df1.write_csv(\"test.csv\")",
    "crumbs": [
      "Get Started",
      "Outputs",
      "Outputting and saving as a DataFrame"
    ]
  },
  {
    "objectID": "usage/03_Custom_Classes/index.html",
    "href": "usage/03_Custom_Classes/index.html",
    "title": "Customizing Sequence Interval Classes",
    "section": "",
    "text": "The core class in aligned-textgrid is the SequenceInterval from which new sequence interval classes can be subclassed. The Word and Phone classes are, themselves, subclasses of SequenceInterval.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import SequenceInterval\nfrom aligned_textgrid import Word, Phone\nfrom aligned_textgrid import custom_classes\n\nissubclass(Word, SequenceInterval)\n\nTrue\nThe most important information every sequence interval class has is its .superset_class and .subset_class, which needs to be another (but different!) SequenceInterval subclass.\nWord.subset_class\n\naligned_textgrid.sequences.word_and_phone.Phone\nPhone.superset_class\n\naligned_textgrid.sequences.word_and_phone.Word\nWord.subset_class.subset_class\n\naligned_textgrid.sequences.word_and_phone.Bottom_wp",
    "crumbs": [
      "Get Started",
      "Custom Classes",
      "Customizing Sequence Interval Classes"
    ]
  },
  {
    "objectID": "usage/03_Custom_Classes/index.html#creating-custom-classes-with-custom_classes",
    "href": "usage/03_Custom_Classes/index.html#creating-custom-classes-with-custom_classes",
    "title": "Customizing Sequence Interval Classes",
    "section": "Creating custom classes with custom_classes",
    "text": "Creating custom classes with custom_classes\nIf you don‚Äôt want or need any additional bells and whistles beyond what SequenceInterval already provides, you can just use the custom_classes() function. For example, if you wanted your own interval classes for a Word, Syllable, and Phone:\n\nMyWord, Syllable, MyPhone = custom_classes(\n    class_list=[\"MyWord\", \"Syllable\", \"Phone\"]\n)\n\n\n[MyWord.subset_class, Syllable.superset_class]\n\n[aligned_textgrid.custom_classes.Syllable,\n aligned_textgrid.custom_classes.MyWord]\n\n\nThe reciprocal .subset_class and .superset_class relationships will be set from left to right for the class names provided to class_list.\n\nUsing custom_classes() when creating an AlignedTextGrid\nThe custom_classes() returns a list of sequence interval classes, which is also a requried input when creating a new AlignedTextGrid object, so you you could create the new sequence interval classes on the fly.\nLet‚Äôs say you began with this textgrid representing the syllable structure of a word:\n\n\n\nsyllable structure textgrid\n\n\nYou could create an AlignedTextGrid object like so:\n\nspritely = AlignedTextGrid(\n    textgrid_path = \"../resources/spritely.TextGrid\",\n    entry_classes = custom_classes(\n        class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"]\n    )\n)\n\nWe can see that the textgrid was successfully parsed by printing spritely.\n\nprint(spritely)\n\nAlignedTextGrid with 1 groups, each with [6] tiers. [['PrWord', 'Foot', 'Syl', 'OnsetRime', 'SylPart', 'Phone']]\n\n\nWithin the first tier group, the tier with index 4 is the SylPart tier. Printing it, we can see that its superset class has been set to OnsetRime and its subset class has been set to Phone.\n\nprint(spritely[0][4])\n\nSequence tier of SylPart; .superset_class: OnsetRime; .subset_class: Phone\n\n\nWe can look at the labels for this tier:\n\nprint(spritely[0][4].labels)\n\n['', 'Onset', 'Nucleus', 'Coda', 'Onset', 'Nucleus', '']\n\n\nAnd we can print out some information about the index 1 interval.\n\nprint(spritely[0][4][1].label)\nprint(spritely[0][4][1].sub_labels)\n\nOnset\n['S', 'P', 'R']\n\n\n\n\nWhen the tier order != the hierarchy order\nIt‚Äôs possible that you‚Äôll be working with textgrids where the largest superset is not the topmost tier. For example, here is the spritely textgrid reversed.\n\n\n\nspritely reversed\n\n\nThe custom_classes() function still needs the hierarchy to be arranged from left to right, but you can also specify a return_order, either by numeric index or by name, that the new classes get returned.\n\ncustom_classes(\n    class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"],\n    return_order=[5, 4, 3, 2, 1, 0]\n)\n# -or-\n# custom_classes(\n#     class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"],\n#     return_order=[\"Phone\", \"SylPart\", \"OnsetRime\", \"Syl\", \"Foot\", \"PrWord\"]\n# )\n\n[aligned_textgrid.custom_classes.Phone,\n aligned_textgrid.custom_classes.SylPart,\n aligned_textgrid.custom_classes.OnsetRime,\n aligned_textgrid.custom_classes.Syl,\n aligned_textgrid.custom_classes.Foot,\n aligned_textgrid.custom_classes.PrWord]\n\n\nThe order of these classes in the output list may have Phone first, but the topmost class in the hierarchy is still PrWord\n\nspritely_rev = AlignedTextGrid(\n    textgrid_path= \"../resources/spritely_rev.TextGrid\",\n    entry_classes = custom_classes(\n        class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"],\n        return_order=[5, 4, 3, 2, 1, 0]        \n    )\n)\nprint(spritely_rev)\n\nAlignedTextGrid with 1 groups, each with [6] tiers. [['PrWord', 'Foot', 'Syl', 'OnsetRime', 'SylPart', 'Phone']]",
    "crumbs": [
      "Get Started",
      "Custom Classes",
      "Customizing Sequence Interval Classes"
    ]
  },
  {
    "objectID": "usage/03_Custom_Classes/index.html#customizing-subclasses",
    "href": "usage/03_Custom_Classes/index.html#customizing-subclasses",
    "title": "Customizing Sequence Interval Classes",
    "section": "Customizing Subclasses",
    "text": "Customizing Subclasses\nThe classes generated by custom_classes() have only the default attributes and methods available within SequenceInterval. If you want any more customized methods or attributes within a sequence interval, you‚Äôll need to create the subclass yourself. For example, let‚Äôs say you wanted to create a custom MyWord, Syllable, SyllablePieces, MyPhone classes, where the Syllable class had as an attribute .has_onset, and .open_syllable. The goal parsing for a word like ‚Äúsprinted‚Äù is illustrated below.\n\n\n\nsprinted\n\n\n\nThe minimal requirements\nThe minimal requirements for a custom class are:\n\nIt is a subclass of SequenceInterval.\nEither its .superset_class has been set with .set_superset_class, or its .subset_class has been set with .set_subset_class.\n\n\nSubclassing SequenceInterval\nHere‚Äôs the minimal setup to create a sequence interval subclass.\n\nclass MyWord(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\nTo test your new subclass, you‚Äôll have to import Interval from praatio.\n\nfrom praatio.utilities.constants import Interval\n\nMyWord(Interval(0, 1, \"test\"))\n\nClass MyWord, label: test, .superset_class: Top, .super_instance, None, .subset_class: Bottom\n\n\nAs you can see, MyWord has defaulted to have Top as its superset class and Bottom as its subset class. We‚Äôll reset these after creating the remaining subclasses. Both SyllablePart and MyPhone will be created the exact same way as MyWord, since we‚Äôre just using the sequence interval defaults for them.\n\nclass SyllablePart(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\nclass MyPhone(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\nFor the specialized properties of Syllable, we‚Äôll start the subclassing the same, but add some properties that return True or False for whether or not the syllable has an onset or a coda.\n\nclass Syllable(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\n    @property\n    def has_onset(self):\n        return \"O\" in self.sub_labels\n    \n    @property\n    def open_syllable(self):\n        return \"C\" not in self.sub_labels\n\nNow, after parsing a properly constructed TextGrid, any instance of the syllable class will return True if ‚ÄúO‚Äù is in its subset labels (has an onset), and will return True if ‚ÄúC‚Äù is not in its subset labels (does not have a coda).\n\n\nSetting subset and superset classes.\nWe can now set the superset_class and subset_class relationships. These relationships are symmetrical, so we actually only need to set one or the other.\n\nMyWord.set_subset_class(Syllable)\nSyllable.set_subset_class(SyllablePart)\nSyllablePart.set_subset_class(MyPhone)\n\nWe can double check the superset classes have been correctly set.\n\nMyPhone.superset_class\n\n__main__.SyllablePart\n\n\n\nSyllablePart.superset_class\n\n__main__.Syllable\n\n\n\nSyllable.superset_class\n\n__main__.MyWord",
    "crumbs": [
      "Get Started",
      "Custom Classes",
      "Customizing Sequence Interval Classes"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html",
    "href": "usage/01_TextGrids/01_tg-nav.html",
    "title": "Navigating an AlignedTextGrid",
    "section": "",
    "text": "This documentation covers reading in the output from the Montreal Forced Aligner using the Word and Phone classes from aligned_textgrid, but everything will generalize to custom classes.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "Navigating an `AlignedTextGrid`"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html#reading-in-a-textgrid",
    "href": "usage/01_TextGrids/01_tg-nav.html#reading-in-a-textgrid",
    "title": "Navigating an AlignedTextGrid",
    "section": "Reading in a TextGrid",
    "text": "Reading in a TextGrid\nTo read in a one-speaker TextGrid, either give AlignedTextGrid() the path to the file, or a textgrid that has already been read in with praatio.textgrid.openTextgrid().\nYou also need to specify the sequence classes of each tier in the order they appear. For MFA output, the top tier is Word and the bottom tier is Phone, but if these were reversed, you would have to pass [Phone, Word] to entry_classes. The information about which class is the superset and which is the subset is encoded in the class information, and is automatically handled.\n\none_speaker = AlignedTextGrid(\n    textgrid_path = \"../resources/josef-fruehwald_speaker.TextGrid\", \n    entry_classes = [Word, Phone]\n)\n\nWith a two or more speaker TextGrid, you can either pass entry_classes a single list of interval classes to re-use with each speaker (for example [Word, Phone]), or an explicit list of nested classes (for example, [[Word, Phone], [Word, Phone]]).\n\ntwo_speaker = AlignedTextGrid(\n    textgrid_path = \"../resources/KY25A_1.TextGrid\",\n    entry_classes= [Word, Phone]\n)\n\nIf you have a textgrid a mixture of sequence hierarchies, you have to read it in with then fully nested list of classes.\n\nfrom aligned_textgrid import custom_classes\nTurn = custom_classes(\"Turn\")\n\nmulti_hierarchy = AlignedTextGrid(\n    textgrid_path = \"../resources/KY25A_1_multi.TextGrid\",\n    entry_classes = [[Word, Phone], [Turn], [Word, Phone], [Turn]]\n)\n\nprint(multi_hierarchy)\n\nAlignedTextGrid with 4 groups, each with [2, 1, 2, 1] tiers. [['Word', 'Phone'], ['Turn'], ['Word', 'Phone'], ['Turn']]",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "Navigating an `AlignedTextGrid`"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html#navigating-the-alignedtextgrid-object",
    "href": "usage/01_TextGrids/01_tg-nav.html#navigating-the-alignedtextgrid-object",
    "title": "Navigating an AlignedTextGrid",
    "section": "Navigating the AlignedTextGrid object",
    "text": "Navigating the AlignedTextGrid object\nEvery AlignedTextGrid object contains at least one TierGroup, which in turn contains at least one SequenceTier.\n\n\n\naligned-textgrid\n\n\nThis information is available if you print the object:\n\nprint(two_speaker)\n\nAlignedTextGrid with 2 groups, each with [2, 2] tiers. [['Word', 'Phone'], ['Word', 'Phone']]\n\n\nOr if you compare the len() of the one speaker vs two speaker textgrids.‚Äù\n\nprint(len(one_speaker))\nprint(len(two_speaker))\n\n1\n2\n\n\nTo get the Word tier of the first speaker in one_speaker, we can index it with [0][0]\n\none_speaker[0][0]\n\nSequence tier of Word; .superset_class: Top_wp; .subset_class: Phone\n\n\nIf you‚Äôd prefer to wrote more verbose but explicit code, you can also access tiers via the .tier_groups and .tier_list attributes as well.\n\none_speaker.tier_groups[0].tier_list[0]\n\nSequence tier of Word; .superset_class: Top_wp; .subset_class: Phone\n\n\nTo access the individual sequence intervals in a tier, you can also use indexing.\n\none_speaker[0][0][3]\n\nClass Word, label: sunlight, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['S', 'AH1', 'N', 'L', 'AY2', 'T']\n\n\nTiers are also iterable.\n\nfor i in range(5):\n    print(one_speaker[0][0][i].label)\n\n\nwhen\nthe\nsunlight\nstrikes\n\n\nOnce you‚Äôve gotten to a sequence interval, indexing goes into its .subset_list\nThe len() of a tier returns how many sequence intervals it constains.\n\n[len(one_speaker[0][0]), len(one_speaker[0][1])]\n\n[377, 1191]",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "Navigating an `AlignedTextGrid`"
    ]
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html#get-interval-at-time",
    "href": "usage/01_TextGrids/01_tg-nav.html#get-interval-at-time",
    "title": "Navigating an AlignedTextGrid",
    "section": "Get interval at time",
    "text": "Get interval at time\nThe ‚ÄúGet interval at time‚Äù functionality from Praat has been implemented for each level of TextGrid representation.\n\nspeaker_one = two_speaker[0]\nspeaker_one_word = speaker_one[0]\n\n\nspeaker_one_word.get_interval_at_time(11)\n\n1\n\n\nThis is the index for the word that appears at 11 seconds.\n\nspeaker_one.get_intervals_at_time(11)\n\n[1, 2]\n\n\nThese are the indices for the word and phone tiers that are at 11 seconds.\n\ntwo_speaker.get_intervals_at_time(11)\n\n[[1, 2], [39, 96]]\n\n\n\ntwo_speaker.get_intervals_at_time(11)\n\n[[1, 2], [39, 96]]\n\n\nThese are the indices for the word and phone tiers for both speakers at 11 seconds.\n\nNested indexing\nYou can use the nested indices returned by .get_intervals_at_time() to get the actual sequence intervals as well.\n\neleven_seconds = two_speaker.get_intervals_at_time(11)\ntwo_speaker[eleven_seconds]\n\n[[Class Word, label: yeah, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['Y', 'AE1'],\n  Class Phone, label: AE1, .superset_class: Word, .super_instance: yeah, .subset_class: Bottom_wp],\n [Class Word, label: after, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['AE1', 'F', 'T', 'ER0'],\n  Class Phone, label: F, .superset_class: Word, .super_instance: after, .subset_class: Bottom_wp]]",
    "crumbs": [
      "Get Started",
      "TextGrids",
      "Navigating an `AlignedTextGrid`"
    ]
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html",
    "href": "usage/04_Points/00_points_and_point_tiers.html",
    "title": "Points",
    "section": "",
    "text": "Praat points are represented using the SequencePoint class, which is much less constrained than the SequenceInterval class. They don‚Äôt have hierarchical relationships defined, and the same SequencePoint subclass can exist within a single SequencePointTier.\nfrom aligned_textgrid import SequencePoint, SequenceInterval, \\\n    SequenceTier, SequencePointTier, \\\n        AlignedTextGrid\nfrom aligned_textgrid import custom_classes\nTo read in a TextGrid with a mixture of intervals and points (download link), you‚Äôll need to provide both SequenceInterval and SequencePoint entry classes. Both can be created with the custom_classes() function. By default, a list of strings will create SequenceInterval subclasses, but you can add indicies of which classes should be SequencePoint subclasses.\nWord, Phone = custom_classes([\"Word\", \"Phone\"])\nRanges = custom_classes(\"Ranges\")\n\nToBI, PrStr, TurningPoints, Levels = custom_classes(\n    [\"ToBI\", \"PrStr\", \"TurningPoints\", \"Levels\"], \n    points=[0, 1, 2, 3]\n)\nNow you can read in the TextGrid using these custom classes. entry_classes should be a list of list indicating how the tiers are nested (or not.)\ntg = AlignedTextGrid(\n    textgrid_path = \"../resources/amelia_knew2-basic.TextGrid\",\n    entry_classes = [\n        [Word, Phone],\n        [ToBI, PrStr, TurningPoints, Levels],\n        [Ranges]\n    ]\n)\ntg\n\nAlignedTextGrid with 3 groups, each with [2, 4, 1] tiers. [['Word', 'Phone'], ['ToBI', 'PrStr', 'TurningPoints', 'Levels'], ['Ranges']]",
    "crumbs": [
      "Get Started",
      "Points",
      "Points"
    ]
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html#navigating-a-sequencepointtier",
    "href": "usage/04_Points/00_points_and_point_tiers.html#navigating-a-sequencepointtier",
    "title": "Points",
    "section": "Navigating a SequencePointTier",
    "text": "Navigating a SequencePointTier\nMost of the same rules apply to navigating a SequencePointTier as a SequenceTier. Let‚Äôs grab the Levels tier for example\n\nlevels_tier = tg[1][3]\n\nEach point in the levels tier can be accessed either by iteration or by indexing.\n\nlevels_tier[0]\n\nClass Levels, label: 2; tier_index: 0\n\n\n\nfor point in levels_tier:\n    print(point)\n\nClass Levels, label: 2; tier_index: 0\nClass Levels, label: 1; tier_index: 1\nClass Levels, label: 5; tier_index: 2\nClass Levels, label: 1; tier_index: 3\nClass Levels, label: 1; tier_index: 4\nClass Levels, label: 3; tier_index: 5\n\n\nThe .fol and .prev relationships are also defined for points.\n\nlevels_tier[1].fol\n\nClass Levels, label: 5; tier_index: 2\n\n\n\nlevels_tier[1].fol.fol\n\nClass Levels, label: 1; tier_index: 3\n\n\n\nlevels_tier[1].prev\n\nClass Levels, label: 2; tier_index: 0",
    "crumbs": [
      "Get Started",
      "Points",
      "Points"
    ]
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepoint-attributes",
    "href": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepoint-attributes",
    "title": "Points",
    "section": "Useful SequencePoint attributes",
    "text": "Useful SequencePoint attributes\nThe most useful attributes of a SequencePoint will be its .label and its .time\n\nexample_point = levels_tier[1]\n\nexample_point.label\n\n'1'\n\n\n\nexample_point.time\n\n0.20235139465888988\n\n\nThe labels and times of all points in a SequencePointTier can be accessed with .labels and .times.\n\n# accessing the parent tier\nexample_point.intier.labels\n\n['2', '1', '5', '1', '1', '3']\n\n\n\nexample_point.intier.times\n\narray([0.08467382, 0.20235139, 0.36102389, 0.51020478, 0.73123339,\n       0.83802   ])\n\n\nThere are also attributes giving the distance between the current point and its .fol and .prev point.\n\nexample_point.fol_distance\n\n0.15867249135026215\n\n\n\nexample_point.prev_distance\n\n-0.11767757671157641",
    "crumbs": [
      "Get Started",
      "Points",
      "Points"
    ]
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepointmethods",
    "href": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepointmethods",
    "title": "Points",
    "section": "Useful SequencePointMethods",
    "text": "Useful SequencePointMethods\nWith the .get_interval_at_time() method, you can get the interval a point falls within if passed a SequenceTier.\n\nphone_tier = tg[0][1]\n\n\nphone_tier.labels\n\n['', '\\\\sw', 'm', 'i', 'l', 'j', '\\\\sw', 'n', 'u', '\\\\sw', 'm', '']\n\n\n\nexample_point.get_interval_at_point(phone_tier)\n\nClass Phone, label: i, .superset_class: Word, .super_instance: Amelia, .subset_class: Bottom_1\n\n\nIf passed any given SequenceInterval or SequencePoint, the .distance_from() method will give the distance from the current point.\n\nexample_interval = example_point.get_interval_at_point(phone_tier)\n\nexample_point.distance_from(example_interval)\n\narray([ 0.01603854, -0.11062785])\n\n\n\nexample_point.distance_from(example_interval.fol)\n\narray([-0.11062785, -0.18968809])",
    "crumbs": [
      "Get Started",
      "Points",
      "Points"
    ]
  }
]