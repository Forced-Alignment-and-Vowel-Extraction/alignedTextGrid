[
  {
    "objectID": "reference/SequenceInterval.html",
    "href": "reference/SequenceInterval.html",
    "title": "SequenceInterval",
    "section": "",
    "text": "sequences.sequences.SequenceInterval(self, Interval=Interval(None, None, None))\nA class to describe an interval with precedence relationships and hierarchical relationships\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA Praat textgrid Interval\nInterval(None, None, None)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nstart\nfloat\nStart time of the interval\n\n\nend\nfloat\nEnd time of the interval\n\n\nlabel\nAny\nLabel of the interval\n\n\nintier\nSequenceTier\nThe sequence tier the current interval is within.\n\n\ntier_index\nint\nThe index of sequence within its tier.\n\n\nfol\nSequenceInterval\nInstance of the following interval. Is the same subclass as the current instance.\n\n\nprev\nSequenceInterval\nInstance of the previous interval. Is the same subclass as current instance.\n\n\nsuper_instance\nSequenceInterval\nThe instance of the superset. Cannot be the same subclass as the current instance.\n\n\nsubset_list\nList[SequenceInterval]\nA list of subset instances. Cannot be the same subclass of the current instance.\n\n\nsub_starts\nnumpy.ndarray\nA numpy array of start times for the subset list\n\n\nsub_ends\nnumpy.ndarray\nA numpy array of end times for the subset list\n\n\nsub_labels\nList[Any]\nA list of labels from the subset list\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfuse_leftwards\nFuse the current segment with the previous segment\n\n\nfuse_rightwards\nFuse the current segment with the following segment\n\n\nindex\nReturns subset instance index\n\n\npop\nPop a sequence interval from the subset list\n\n\nset_feature\nSets arbitrary object attribute\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_leftwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the previous segment\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_rightwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the following segment\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.index(subset_instance)\nReturns subset instance index\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA subset instance to get the index of.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of subset_instance\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.pop(subset_instance)\nPop a sequence interval from the subset list\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA sequence interval to pop\nrequired\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.set_feature(feature, value)\nSets arbitrary object attribute\nThis will be most useful for creating custom subclasses.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfeature\nstr\nNew attribute name\nrequired\n\n\nvalue\nAny\nNew attribute value\nrequired"
  },
  {
    "objectID": "reference/SequenceInterval.html#parameters",
    "href": "reference/SequenceInterval.html#parameters",
    "title": "SequenceInterval",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA Praat textgrid Interval\nInterval(None, None, None)"
  },
  {
    "objectID": "reference/SequenceInterval.html#attributes",
    "href": "reference/SequenceInterval.html#attributes",
    "title": "SequenceInterval",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nstart\nfloat\nStart time of the interval\n\n\nend\nfloat\nEnd time of the interval\n\n\nlabel\nAny\nLabel of the interval\n\n\nintier\nSequenceTier\nThe sequence tier the current interval is within.\n\n\ntier_index\nint\nThe index of sequence within its tier.\n\n\nfol\nSequenceInterval\nInstance of the following interval. Is the same subclass as the current instance.\n\n\nprev\nSequenceInterval\nInstance of the previous interval. Is the same subclass as current instance.\n\n\nsuper_instance\nSequenceInterval\nThe instance of the superset. Cannot be the same subclass as the current instance.\n\n\nsubset_list\nList[SequenceInterval]\nA list of subset instances. Cannot be the same subclass of the current instance.\n\n\nsub_starts\nnumpy.ndarray\nA numpy array of start times for the subset list\n\n\nsub_ends\nnumpy.ndarray\nA numpy array of end times for the subset list\n\n\nsub_labels\nList[Any]\nA list of labels from the subset list"
  },
  {
    "objectID": "reference/SequenceInterval.html#methods",
    "href": "reference/SequenceInterval.html#methods",
    "title": "SequenceInterval",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfuse_leftwards\nFuse the current segment with the previous segment\n\n\nfuse_rightwards\nFuse the current segment with the following segment\n\n\nindex\nReturns subset instance index\n\n\npop\nPop a sequence interval from the subset list\n\n\nset_feature\nSets arbitrary object attribute\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_leftwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the previous segment\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_rightwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the following segment\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.index(subset_instance)\nReturns subset instance index\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA subset instance to get the index of.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of subset_instance\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.pop(subset_instance)\nPop a sequence interval from the subset list\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA sequence interval to pop\nrequired\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.set_feature(feature, value)\nSets arbitrary object attribute\nThis will be most useful for creating custom subclasses.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfeature\nstr\nNew attribute name\nrequired\n\n\nvalue\nAny\nNew attribute value\nrequired"
  },
  {
    "objectID": "reference/PrStr.html",
    "href": "reference/PrStr.html",
    "title": "PrStr",
    "section": "",
    "text": "polar.polar_classes.PrStr(self, Point)\nPrStr tier points\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‘?’ was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nstatus\nstr\n'edge' or 'prominence'"
  },
  {
    "objectID": "reference/PrStr.html#attributes",
    "href": "reference/PrStr.html#attributes",
    "title": "PrStr",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‘?’ was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nstatus\nstr\n'edge' or 'prominence'"
  },
  {
    "objectID": "reference/Misc.html",
    "href": "reference/Misc.html",
    "title": "Misc",
    "section": "",
    "text": "Misc\npolar.polar_classes.Misc()\nMisc points\n\n\n\n\nReuseGPLv3"
  },
  {
    "objectID": "reference/Phone.html",
    "href": "reference/Phone.html",
    "title": "Phone",
    "section": "",
    "text": "sequences.word_and_phone.Phone(self, Interval=Interval(None, None, None))\nA Phone subclass of SequenceInterval\nHas all the same methods and attributes as SequenceInterval in addition to attributes described below. superset_class set to Word, and subset_class set to Bottom\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA praatio Inteval\nInterval(None, None, None)\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ninword\nWord\nThe word instance this phone appears in.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_word\nConvenience function to set word for this Phone\n\n\n\n\n\nsequences.word_and_phone.Phone.set_word(word)\nConvenience function to set word for this Phone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nword\nWord\nWord instance.\nrequired"
  },
  {
    "objectID": "reference/Phone.html#parameters",
    "href": "reference/Phone.html#parameters",
    "title": "Phone",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA praatio Inteval\nInterval(None, None, None)"
  },
  {
    "objectID": "reference/Phone.html#attributes",
    "href": "reference/Phone.html#attributes",
    "title": "Phone",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ninword\nWord\nThe word instance this phone appears in."
  },
  {
    "objectID": "reference/Phone.html#methods",
    "href": "reference/Phone.html#methods",
    "title": "Phone",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_word\nConvenience function to set word for this Phone\n\n\n\n\n\nsequences.word_and_phone.Phone.set_word(word)\nConvenience function to set word for this Phone\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nword\nWord\nWord instance.\nrequired"
  },
  {
    "objectID": "reference/custom_classes.html",
    "href": "reference/custom_classes.html",
    "title": "custom_classes",
    "section": "",
    "text": "custom_classes.custom_classes(class_list=[], return_order=None, points=[])\nGenerate custom interval classes\nPassing custom_classes() a list of Sequence names wil return a list of SequenceInterval subclasses with those names. The first name passed to class_list will be at the top of the hierarchy, the second name will be the subset class of the first, and so on.\nTo change the order in which the custom classes are returned, specify return_order with either indices or class names. For example, if you have Words, Syllables, and Phones in a hierarchical relationship in a textgrid, you can run the following:\ncustom_classes([\"Word\", \"Syllable\", \"Phone\"])\n# [alignedTextGrid.custom_classes.Word,\n#  alignedTextGrid.custom_classes.Syllable,\n#  alignedTextGrid.custom_classes.Phone]\nBut if the order of the textgrid tiers has Word as the bottom tier and Phone as the top, you can specify return_order like so:\ncustom_classes(\n    class_list = [\"Word\", \"Syllable\", \"Phone\"],\n    return_order = [2, 1, 0]\n    # or\n    # return_order = [\"Phone\", \"Syllable\", \"Word]\n)\n# [alignedTextGrid.custom_classes.Phone,\n#  alignedTextGrid.custom_classes.Syllable,\n#  alignedTextGrid.custom_classes.Word]\nThis way, you can use custom_classes() directly as the entry_classes argument in AlignedTextGrid\nAlignedTextGrid(\n    textgrid_path = \"syllables.TextGrid\",\n    entry_classes = custom_classes(\n        class_list = [\"Word\", \"Syllable\", \"Phone\"],\n        return_order = [2, 1, 0]\n    )\n)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nclass_list\nlist[str]\nA list of desired class names, in their hierarchical order. Defaults to [].\n[]\n\n\nreturn_order\nlist[str] | list[int] | None\nA return order for the custom classes, if not in hierarchical order. Defaults to None.\nNone\n\n\npoints\nlist[int]\nIndices of which classes should be points, rather than intervals\n[]\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[Type[SequenceInterval]]\nA list of custom SequenceInterval subclasses"
  },
  {
    "objectID": "reference/custom_classes.html#parameters",
    "href": "reference/custom_classes.html#parameters",
    "title": "custom_classes",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nclass_list\nlist[str]\nA list of desired class names, in their hierarchical order. Defaults to [].\n[]\n\n\nreturn_order\nlist[str] | list[int] | None\nA return order for the custom classes, if not in hierarchical order. Defaults to None.\nNone\n\n\npoints\nlist[int]\nIndices of which classes should be points, rather than intervals\n[]"
  },
  {
    "objectID": "reference/custom_classes.html#returns",
    "href": "reference/custom_classes.html#returns",
    "title": "custom_classes",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nlist[Type[SequenceInterval]]\nA list of custom SequenceInterval subclasses"
  },
  {
    "objectID": "reference/Levels.html",
    "href": "reference/Levels.html",
    "title": "Levels",
    "section": "",
    "text": "polar.polar_classes.Levels(self, Point)\nA levels point class\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‘?’ was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nlevel\nint\nThe level value given to this point\n\n\nband\nnp.array\nThe f0 band for this point, given its level\n\n\nranges_interval\nRanges\nThe Ranges interval this point falls within\n\n\nranges_tier\nSequenceTier\nThe Ranges tier associated with these Levels\n\n\nturning_point\nTurningPoints\nThe TurningPoints point associated with this Levels point"
  },
  {
    "objectID": "reference/Levels.html#attributes",
    "href": "reference/Levels.html#attributes",
    "title": "Levels",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint\n\n\ncertainty\nstr\nIf a ‘?’ was appended to a point label, 'uncertain', otherwise 'certain'\n\n\nlevel\nint\nThe level value given to this point\n\n\nband\nnp.array\nThe f0 band for this point, given its level\n\n\nranges_interval\nRanges\nThe Ranges interval this point falls within\n\n\nranges_tier\nSequenceTier\nThe Ranges tier associated with these Levels\n\n\nturning_point\nTurningPoints\nThe TurningPoints point associated with this Levels point"
  },
  {
    "objectID": "reference/TierMixins.html",
    "href": "reference/TierMixins.html",
    "title": "TierMixins",
    "section": "",
    "text": "mixins.tiermixins.TierMixins()\nMethods and attributes for Sequence Tiers\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n[]\n\nindexable and iterable\n\n\nfirst\nSequenceInterval\nThe first entry in the tier.\n\n\nlast\nSequenceInterval\nThe last entry in the tier.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nindex\nReturn index of a tier entry\n\n\n\n\n\nmixins.tiermixins.TierMixins.index(entry)\nReturn index of a tier entry\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSequencePoint | SequenceInterval\nA SequenceInterval or a PointInterval to get the index of.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe entry’s index"
  },
  {
    "objectID": "reference/TierMixins.html#attributes",
    "href": "reference/TierMixins.html#attributes",
    "title": "TierMixins",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n[]\n\nindexable and iterable\n\n\nfirst\nSequenceInterval\nThe first entry in the tier.\n\n\nlast\nSequenceInterval\nThe last entry in the tier."
  },
  {
    "objectID": "reference/TierMixins.html#methods",
    "href": "reference/TierMixins.html#methods",
    "title": "TierMixins",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nindex\nReturn index of a tier entry\n\n\n\n\n\nmixins.tiermixins.TierMixins.index(entry)\nReturn index of a tier entry\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSequencePoint | SequenceInterval\nA SequenceInterval or a PointInterval to get the index of.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe entry’s index"
  },
  {
    "objectID": "reference/sequences.sequences.SequenceInterval.html",
    "href": "reference/sequences.sequences.SequenceInterval.html",
    "title": "sequences.sequences.SequenceInterval",
    "section": "",
    "text": "sequences.sequences.SequenceInterval(self, Interval=Interval(None, None, None))\nA class to describe an interval with precedence relationships and hierarchical relationships\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA Praat textgrid Interval\nInterval(None, None, None)\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nstart\nfloat\nStart time of the interval\n\n\nend\nfloat\nEnd time of the interval\n\n\nlabel\nAny\nLabel of the interval\n\n\nintier\nSequenceTier\nThe sequence tier the current interval is within.\n\n\ntier_index\nint\nThe index of sequence within its tier.\n\n\nfol\nSequenceInterval\nInstance of the following interval. Is the same subclass as the current instance.\n\n\nprev\nSequenceInterval\nInstance of the previous interval. Is the same subclass as current instance.\n\n\nsuper_instance\nSequenceInterval\nThe instance of the superset. Cannot be the same subclass as the current instance.\n\n\nsubset_list\nList[SequenceInterval]\nA list of subset instances. Cannot be the same subclass of the current instance.\n\n\nsub_starts\nnumpy.ndarray\nA numpy array of start times for the subset list\n\n\nsub_ends\nnumpy.ndarray\nA numpy array of end times for the subset list\n\n\nsub_labels\nList[Any]\nA list of labels from the subset list\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfuse_leftwards\nFuse the current segment with the previous segment\n\n\nfuse_rightwards\nFuse the current segment with the following segment\n\n\nindex\nReturns subset instance index\n\n\npop\nPop a sequence interval from the subset list\n\n\nset_feature\nSets arbitrary object attribute\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_leftwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the previous segment\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_rightwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the following segment\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.index(subset_instance)\nReturns subset instance index\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA subset instance to get the index of.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of subset_instance\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.pop(subset_instance)\nPop a sequence interval from the subset list\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA sequence interval to pop\nrequired\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.set_feature(feature, value)\nSets arbitrary object attribute\nThis will be most useful for creating custom subclasses.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfeature\nstr\nNew attribute name\nrequired\n\n\nvalue\nAny\nNew attribute value\nrequired"
  },
  {
    "objectID": "reference/sequences.sequences.SequenceInterval.html#parameters",
    "href": "reference/sequences.sequences.SequenceInterval.html#parameters",
    "title": "sequences.sequences.SequenceInterval",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA Praat textgrid Interval\nInterval(None, None, None)"
  },
  {
    "objectID": "reference/sequences.sequences.SequenceInterval.html#attributes",
    "href": "reference/sequences.sequences.SequenceInterval.html#attributes",
    "title": "sequences.sequences.SequenceInterval",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nstart\nfloat\nStart time of the interval\n\n\nend\nfloat\nEnd time of the interval\n\n\nlabel\nAny\nLabel of the interval\n\n\nintier\nSequenceTier\nThe sequence tier the current interval is within.\n\n\ntier_index\nint\nThe index of sequence within its tier.\n\n\nfol\nSequenceInterval\nInstance of the following interval. Is the same subclass as the current instance.\n\n\nprev\nSequenceInterval\nInstance of the previous interval. Is the same subclass as current instance.\n\n\nsuper_instance\nSequenceInterval\nThe instance of the superset. Cannot be the same subclass as the current instance.\n\n\nsubset_list\nList[SequenceInterval]\nA list of subset instances. Cannot be the same subclass of the current instance.\n\n\nsub_starts\nnumpy.ndarray\nA numpy array of start times for the subset list\n\n\nsub_ends\nnumpy.ndarray\nA numpy array of end times for the subset list\n\n\nsub_labels\nList[Any]\nA list of labels from the subset list"
  },
  {
    "objectID": "reference/sequences.sequences.SequenceInterval.html#methods",
    "href": "reference/sequences.sequences.SequenceInterval.html#methods",
    "title": "sequences.sequences.SequenceInterval",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfuse_leftwards\nFuse the current segment with the previous segment\n\n\nfuse_rightwards\nFuse the current segment with the following segment\n\n\nindex\nReturns subset instance index\n\n\npop\nPop a sequence interval from the subset list\n\n\nset_feature\nSets arbitrary object attribute\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_leftwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the previous segment\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.fuse_rightwards(label_fun=lambda x, y: ' '.join([x, y]))\nFuse the current segment with the following segment\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel_fun\nfunction\nFunction for joining interval labels.\nlambda x, y: ' '.join([x, y])\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.index(subset_instance)\nReturns subset instance index\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA subset instance to get the index of.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of subset_instance\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.pop(subset_instance)\nPop a sequence interval from the subset list\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset_instance\nSequenceInterval\nA sequence interval to pop\nrequired\n\n\n\n\n\n\n\nsequences.sequences.SequenceInterval.set_feature(feature, value)\nSets arbitrary object attribute\nThis will be most useful for creating custom subclasses.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfeature\nstr\nNew attribute name\nrequired\n\n\nvalue\nAny\nNew attribute value\nrequired"
  },
  {
    "objectID": "reference/AlignedTextGrid.html",
    "href": "reference/AlignedTextGrid.html",
    "title": "AlignedTextGrid",
    "section": "",
    "text": "aligned_textgrid.AlignedTextGrid(self, textgrid=None, textgrid_path=None, entry_classes=[SequenceInterval])\nAn aligned Textgrid\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntextgrid\nTextgrid\nA praatio TextGrid\nNone\n\n\ntextgrid_path\nstr\nA path to a TextGrid file to be read in with praatio.textgrid.openTextgrid\nNone\n\n\nentry_classes\nSequence[Sequence[Type[SequenceInterval]]] | Sequence[Type[SequenceInterval]]\nIf a single list of SequenceInterval subclasses is given, they will be repeated as many times as necessary to assign a class to every tier. So if there are three speakers, each with a word and phone tier, [Word, Phone] will process them each into a tier group. If your TextGrids are more complex, provide a nested list with the class for each tier within each tier group. Say, if only the first speaker had both a word and phone tier, and the remaining two had only a word tier, [[Word, Phone], [Word], [Word]]\n[SequenceInterval]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nentry_classes\nlist[Sequence[Type[SequenceInterval]]]\nThe entry classes for each tier within a tier group.\n\n\ntier_groups\nlist[TierGroup]\na list of TierGroup\n\n\nxmax\nfloat\nMaximum time\n\n\nxmin\nfloat\nMinimum time\n\n\n[]\n\nindexable\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_intervals_at_time\nGet interval indices at time\n\n\nreturn_textgrid\nConvert this AlignedTextGrid to a praatio Textgrid\n\n\nsave_textgrid\nSaves the current AlignedTextGrid\n\n\n\n\n\naligned_textgrid.AlignedTextGrid.get_intervals_at_time(time)\nGet interval indices at time\nReturns a nested list of intervals at time for each tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[list[int]]\na nested list of interval indices.\n\n\n\n\n\n\n\naligned_textgrid.AlignedTextGrid.return_textgrid()\nConvert this AlignedTextGrid to a praatio Textgrid\nReturns the current object as a praatio.data_classes.textgrid.Textgrid. Useful for saving.\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.data_classes.textgrid.Textgrid\nA praatio Textgrid\n\n\n\n\n\n\n\naligned_textgrid.AlignedTextGrid.save_textgrid(save_path, format='long_textgrid')\nSaves the current AlignedTextGrid\nUses the praatio.data_classes.textgrid.Textgrid.save() method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\npath for saving the textgrid\nrequired\n\n\nformat\nLiteral[‘short_textgrid’, ‘long_textgrid’, ‘json’, ‘textgrid_json’]\nSave format.\n'long_textgrid'"
  },
  {
    "objectID": "reference/AlignedTextGrid.html#parameters",
    "href": "reference/AlignedTextGrid.html#parameters",
    "title": "AlignedTextGrid",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntextgrid\nTextgrid\nA praatio TextGrid\nNone\n\n\ntextgrid_path\nstr\nA path to a TextGrid file to be read in with praatio.textgrid.openTextgrid\nNone\n\n\nentry_classes\nSequence[Sequence[Type[SequenceInterval]]] | Sequence[Type[SequenceInterval]]\nIf a single list of SequenceInterval subclasses is given, they will be repeated as many times as necessary to assign a class to every tier. So if there are three speakers, each with a word and phone tier, [Word, Phone] will process them each into a tier group. If your TextGrids are more complex, provide a nested list with the class for each tier within each tier group. Say, if only the first speaker had both a word and phone tier, and the remaining two had only a word tier, [[Word, Phone], [Word], [Word]]\n[SequenceInterval]"
  },
  {
    "objectID": "reference/AlignedTextGrid.html#attributes",
    "href": "reference/AlignedTextGrid.html#attributes",
    "title": "AlignedTextGrid",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nentry_classes\nlist[Sequence[Type[SequenceInterval]]]\nThe entry classes for each tier within a tier group.\n\n\ntier_groups\nlist[TierGroup]\na list of TierGroup\n\n\nxmax\nfloat\nMaximum time\n\n\nxmin\nfloat\nMinimum time\n\n\n[]\n\nindexable"
  },
  {
    "objectID": "reference/AlignedTextGrid.html#methods",
    "href": "reference/AlignedTextGrid.html#methods",
    "title": "AlignedTextGrid",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_intervals_at_time\nGet interval indices at time\n\n\nreturn_textgrid\nConvert this AlignedTextGrid to a praatio Textgrid\n\n\nsave_textgrid\nSaves the current AlignedTextGrid\n\n\n\n\n\naligned_textgrid.AlignedTextGrid.get_intervals_at_time(time)\nGet interval indices at time\nReturns a nested list of intervals at time for each tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[list[int]]\na nested list of interval indices.\n\n\n\n\n\n\n\naligned_textgrid.AlignedTextGrid.return_textgrid()\nConvert this AlignedTextGrid to a praatio Textgrid\nReturns the current object as a praatio.data_classes.textgrid.Textgrid. Useful for saving.\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.data_classes.textgrid.Textgrid\nA praatio Textgrid\n\n\n\n\n\n\n\naligned_textgrid.AlignedTextGrid.save_textgrid(save_path, format='long_textgrid')\nSaves the current AlignedTextGrid\nUses the praatio.data_classes.textgrid.Textgrid.save() method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\npath for saving the textgrid\nrequired\n\n\nformat\nLiteral[‘short_textgrid’, ‘long_textgrid’, ‘json’, ‘textgrid_json’]\nSave format.\n'long_textgrid'"
  },
  {
    "objectID": "reference/Top.html",
    "href": "reference/Top.html",
    "title": "Top",
    "section": "",
    "text": "Top\nsequences.sequences.Top(self)\nA top level interval class\nThis is a special subclass intended to be the superset_class for classes at the top of the hierarchy.\n\n\n\n\nReuseGPLv3"
  },
  {
    "objectID": "reference/Word.html",
    "href": "reference/Word.html",
    "title": "Word",
    "section": "",
    "text": "sequences.word_and_phone.Word(self, Interval=Interval(None, None, None))\nA Word subclass of SequenceInterval\nHas all the same methods and attributes as SequenceInterval in addition to attributes described below. superset_class set to Top, and subset_class set to Phone\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA praatio Interval\nInterval(None, None, None)\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nphone_list\nlist[Phone]\nA list of Phone objects\n\n\nphones\nlist[str]\nA list of phone labels\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_phones\nConvenience function to set the phones\n\n\n\n\n\nsequences.word_and_phone.Word.set_phones(phone_list)\nConvenience function to set the phones\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nphone_list\nlist[Phone]\nList of Phone instances\nrequired"
  },
  {
    "objectID": "reference/Word.html#parameters",
    "href": "reference/Word.html#parameters",
    "title": "Word",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nInterval\nInterval\nA praatio Interval\nInterval(None, None, None)"
  },
  {
    "objectID": "reference/Word.html#attributes",
    "href": "reference/Word.html#attributes",
    "title": "Word",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nphone_list\nlist[Phone]\nA list of Phone objects\n\n\nphones\nlist[str]\nA list of phone labels"
  },
  {
    "objectID": "reference/Word.html#methods",
    "href": "reference/Word.html#methods",
    "title": "Word",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_phones\nConvenience function to set the phones\n\n\n\n\n\nsequences.word_and_phone.Word.set_phones(phone_list)\nConvenience function to set the phones\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nphone_list\nlist[Phone]\nList of Phone instances\nrequired"
  },
  {
    "objectID": "reference/Bottom.html",
    "href": "reference/Bottom.html",
    "title": "Bottom",
    "section": "",
    "text": "Bottom\nsequences.sequences.Bottom(self)\nA bottom level interval class\nThis is a special subclass intended to be the subset_class for classes at the bottom of the hierarchy.\n\n\n\n\nReuseGPLv3"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aligned TextGrid",
    "section": "",
    "text": "The aligned-textgrid package provides a python interface for representing and operating on TextGrids produced by forced aligners like FAVE or the Montreal Forced Aligner. Classes provided by aligned-textgrid represent hierarchical and precedence relationships among data stored in TextGrid formats allowing for simplified and more accessible analysis of aligned speech data."
  },
  {
    "objectID": "index.html#example-use-cases",
    "href": "index.html#example-use-cases",
    "title": "Aligned TextGrid",
    "section": "Example Use Cases",
    "text": "Example Use Cases\n\nYou want to quickly loop through the Phone tier of a Textgrid, and also access information about the word it is a part of.\nYou want to quickly loop over the Word tier of a Textgrid and quickly count how many phones it has.\nYou want to programmatically merge together adjacent Textgrid intervals.\n\nFor examples on how to use the pacakge, see the Usage pages."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Aligned TextGrid",
    "section": "Installation",
    "text": "Installation\n\nTo install aligned-textgrid using pip, run the following command in your terminal:\npip install aligned-textgrid"
  },
  {
    "objectID": "index.html#not-another-textgrid-implementation",
    "href": "index.html#not-another-textgrid-implementation",
    "title": "Aligned TextGrid",
    "section": "Not another TextGrid implementation",
    "text": "Not another TextGrid implementation\nThere are several other packages that parse Praat Textgrids, including\n\npraatio\ntextgrid\n\naligned-textgrid’s goal is to capture hierarchical and sequential relationships represented in many TextGrids, and to make them easilly accessible to users via an intuitive interface. The goal is that from any arbitrary location within a TextGrid, users can easilly access information with minimally defensive coding.\n\n\nExample\nAs an example, we’ll read in a textgrid produced with forced alignment that contains a single speaker with a word and phone tier.\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone\ntg = AlignedTextGrid(\n    textgrid_path='usage/resources/josef-fruehwald_speaker.TextGrid', \n    entry_classes=[Word, Phone]\n    )\n\nThen, we can access an arbitrary phone interval.\n\narbitrary_interval = tg[0].Phone[20]\n\nFrom this aribitrary interval, we can access information about the intervals preceding and following with the .prev and .fol attributes.\n\nprint(arbitrary_interval.prev.label)\nprint(arbitrary_interval.label)\nprint(arbitrary_interval.fol.label)\n\nR\nEY1\nN\n\n\nWe can also access information about the word this interval is nested within with the .inword attribute.\n\nprint(arbitrary_interval.inword.label)\n\nraindrops\n\n\nThe object returned by .inword is just another interval, meaning we can access informaton about it’s context with the .prev and .fol attributes as well.\n\nprint(arbitrary_interval.inword.prev.label)\nprint(arbitrary_interval.inword.label)\nprint(arbitrary_interval.inword.fol.label)\n\nstrikes\nraindrops\nin"
  },
  {
    "objectID": "index.html#for-more",
    "href": "index.html#for-more",
    "title": "Aligned TextGrid",
    "section": "For more",
    "text": "For more\n\nTo start jumping in, check out the quickstart\nTo learn more about navigating TextGrids and intervals, check out the usage pages on navigating TextGrids and navgiating sequences\nTo learn more about the attributes you can access from textgrids and sequences, see the usage pages on TextGrid attributes and interval attributes\n\nYou can also directly read up on the function and class references."
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html",
    "href": "usage/01_TextGrids/02_tg-info.html",
    "title": "TextGrid and Tier Properties",
    "section": "",
    "text": "There are a few useful pieces of information available at the AlignedTextGrid, TierGroups, and Tier levels\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\ntwo_speaker = AlignedTextGrid(\n    textgrid_path = \"../resources/KY25A_1.TextGrid\",\n    entry_classes= [Word, Phone]\n)"
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#tier-names",
    "href": "usage/01_TextGrids/02_tg-info.html#tier-names",
    "title": "TextGrid and Tier Properties",
    "section": "Tier Names",
    "text": "Tier Names\n\n# AlignedTextGrid level\ntwo_speaker.tier_names\n\n[['KY25A - words', 'KY25A - phones'], ['IVR - words', 'IVR - phones']]\n\n\n\n# TierGroup level\ntwo_speaker[0].tier_names\n\n['KY25A - words', 'KY25A - phones']\n\n\n\n# Tier level\ntwo_speaker[0][0].name \n\n'KY25A - words'"
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#xmin-and-xmax",
    "href": "usage/01_TextGrids/02_tg-info.html#xmin-and-xmax",
    "title": "TextGrid and Tier Properties",
    "section": "xmin and xmax",
    "text": "xmin and xmax\n\n# aligned textgrid level\n[two_speaker.xmin, two_speaker.xmax]\n\n[0.0, 26.774]\n\n\n\n# tier groups level\n[two_speaker[0].xmin, two_speaker[0].xmax]\n\n[0.0, 26.774]\n\n\n\n# tier level\n[two_speaker[0][0].xmin, two_speaker[0][0].xmax]\n\n[0.0, 26.774]"
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#entry-classes",
    "href": "usage/01_TextGrids/02_tg-info.html#entry-classes",
    "title": "TextGrid and Tier Properties",
    "section": "Entry Classes",
    "text": "Entry Classes\n\n# aligned text grid level\ntwo_speaker.entry_classes\n\n[[aligned_textgrid.sequences.word_and_phone.Word,\n  aligned_textgrid.sequences.word_and_phone.Phone],\n [aligned_textgrid.sequences.word_and_phone.Word,\n  aligned_textgrid.sequences.word_and_phone.Phone]]\n\n\n\n# tier group level\ntwo_speaker[0].entry_classes\n\n[aligned_textgrid.sequences.word_and_phone.Word,\n aligned_textgrid.sequences.word_and_phone.Phone]\n\n\n\n# tier level\ntwo_speaker[0][0].entry_class\n\naligned_textgrid.sequences.word_and_phone.Word"
  },
  {
    "objectID": "usage/01_TextGrids/02_tg-info.html#starts-ends-and-labels",
    "href": "usage/01_TextGrids/02_tg-info.html#starts-ends-and-labels",
    "title": "TextGrid and Tier Properties",
    "section": "Starts, ends and labels",
    "text": "Starts, ends and labels\nThese are only implemented at the tier level.\n\n# every start time\ntwo_speaker[0][0].starts\n\narray([ 0.    , 10.7017, 11.0017, 13.3117, 13.6517, 13.9017, 13.9317,\n       14.9717, 15.0017, 15.3117, 15.4517, 15.9417, 16.3217, 17.0217,\n       17.2117, 17.3317, 17.7917, 18.0917, 18.9517, 19.7717, 20.2717,\n       20.6417, 24.3517, 24.7317, 25.1717])\n\n\n\n# every end time\ntwo_speaker[0][0].ends\n\narray([10.7017, 11.0017, 13.3117, 13.6517, 13.9017, 13.9317, 14.9717,\n       15.0017, 15.3117, 15.4517, 15.9417, 16.3217, 17.0217, 17.2117,\n       17.3317, 17.7917, 18.0917, 18.9517, 19.7717, 20.2717, 20.6417,\n       24.3517, 24.7317, 25.1717, 26.774 ])\n\n\n\n# every label\ntwo_speaker[0][0].labels\n\n['',\n 'yeah',\n '',\n 'well',\n 'now',\n '',\n 'you',\n '',\n 'might',\n '',\n 'start',\n 'that',\n '',\n 'i',\n 'was',\n 'born',\n 'in',\n '',\n 'eighteen',\n 'sixty',\n 'seven',\n '',\n 'nintey',\n 'three',\n '']"
  },
  {
    "objectID": "usage/05_Outputs/00_to_textgrid.html",
    "href": "usage/05_Outputs/00_to_textgrid.html",
    "title": "Saving Outputting and Saving as a TextGrid",
    "section": "",
    "text": "Each aligned_textgrid object has a .return_*() method that returns its corresponding praatio object.\n\nsequence_interval.return_interval() returns a praatio interval\nsequence_interval.return_tier() returns a praatio interval tier\naligned_textgrid.return_textgrid() returns a praatio TextGrid\n\nHere’s an example.\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone\n\ntg = AlignedTextGrid(\n    textgrid_path=\"../resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\n\n\n\n\ntg[0].Phone.first.return_interval()\n\nInterval(start=0.0, end=0.11, label='')\n\n\n\n\n\n\ntg[0].Phone.return_tier()\n\n&lt;praatio.data_classes.interval_tier.IntervalTier at 0x123077dc0&gt;\n\n\n\n\n\n\ntg.return_textgrid()\n\n&lt;praatio.data_classes.textgrid.Textgrid at 0x1230776d0&gt;"
  },
  {
    "objectID": "usage/05_Outputs/00_to_textgrid.html#outputting-textgrids",
    "href": "usage/05_Outputs/00_to_textgrid.html#outputting-textgrids",
    "title": "Saving Outputting and Saving as a TextGrid",
    "section": "",
    "text": "Each aligned_textgrid object has a .return_*() method that returns its corresponding praatio object.\n\nsequence_interval.return_interval() returns a praatio interval\nsequence_interval.return_tier() returns a praatio interval tier\naligned_textgrid.return_textgrid() returns a praatio TextGrid\n\nHere’s an example.\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone\n\ntg = AlignedTextGrid(\n    textgrid_path=\"../resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\n\n\n\n\ntg[0].Phone.first.return_interval()\n\nInterval(start=0.0, end=0.11, label='')\n\n\n\n\n\n\ntg[0].Phone.return_tier()\n\n&lt;praatio.data_classes.interval_tier.IntervalTier at 0x123077dc0&gt;\n\n\n\n\n\n\ntg.return_textgrid()\n\n&lt;praatio.data_classes.textgrid.Textgrid at 0x1230776d0&gt;"
  },
  {
    "objectID": "usage/05_Outputs/00_to_textgrid.html#saving-a-textgrid",
    "href": "usage/05_Outputs/00_to_textgrid.html#saving-a-textgrid",
    "title": "Saving Outputting and Saving as a TextGrid",
    "section": "Saving a TextGrid",
    "text": "Saving a TextGrid\nYou can save an aligned textgrid to a .TextGrid file with the .save_textgrid() method.\n\ntg.save_textgrid(\n    save_path=\"new.TextGrid\"\n)"
  },
  {
    "objectID": "usage/03_Custom_Classes/index.html",
    "href": "usage/03_Custom_Classes/index.html",
    "title": "Customizing Sequence Interval Classes",
    "section": "",
    "text": "The core class in aligned-textgrid is the SequenceInterval from which new sequence interval classes can be subclassed. The Word and Phone classes are, themselves, subclasses of SequenceInterval.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import SequenceInterval\nfrom aligned_textgrid import Word, Phone\nfrom aligned_textgrid import custom_classes\n\nissubclass(Word, SequenceInterval)\n\nTrue\nThe most important information every sequence interval class has is its .superset_class and .subset_class, which needs to be another (but different!) SequenceInterval subclass.\nWord.subset_class\n\naligned_textgrid.sequences.word_and_phone.Phone\nPhone.superset_class\n\naligned_textgrid.sequences.word_and_phone.Word\nWord.subset_class.subset_class\n\naligned_textgrid.sequences.word_and_phone.Bottom_wp"
  },
  {
    "objectID": "usage/03_Custom_Classes/index.html#creating-custom-classes-with-custom_classes",
    "href": "usage/03_Custom_Classes/index.html#creating-custom-classes-with-custom_classes",
    "title": "Customizing Sequence Interval Classes",
    "section": "Creating custom classes with custom_classes",
    "text": "Creating custom classes with custom_classes\nIf you don’t want or need any additional bells and whistles beyond what SequenceInterval already provides, you can just use the custom_classes() function. For example, if you wanted your own interval classes for a Word, Syllable, and Phone:\n\nMyWord, Syllable, MyPhone = custom_classes(\n    class_list=[\"MyWord\", \"Syllable\", \"Phone\"]\n)\n\n\n[MyWord.subset_class, Syllable.superset_class]\n\n[aligned_textgrid.custom_classes.Syllable,\n aligned_textgrid.custom_classes.MyWord]\n\n\nThe reciprocal .subset_class and .superset_class relationships will be set from left to right for the class names provided to class_list.\n\nUsing custom_classes() when creating an AlignedTextGrid\nThe custom_classes() returns a list of sequence interval classes, which is also a requried input when creating a new AlignedTextGrid object, so you you could create the new sequence interval classes on the fly.\nLet’s say you began with this textgrid representing the syllable structure of a word:\n\n\n\nsyllable structure textgrid\n\n\nYou could create an AlignedTextGrid object like so:\n\nspritely = AlignedTextGrid(\n    textgrid_path = \"../resources/spritely.TextGrid\",\n    entry_classes = custom_classes(\n        class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"]\n    )\n)\n\nWe can see that the textgrid was successfully parsed by printing spritely.\n\nprint(spritely)\n\nAlignedTextGrid with 1 groups, each with [6] tiers. [['PrWord', 'Foot', 'Syl', 'OnsetRime', 'SylPart', 'Phone']]\n\n\nWithin the first tier group, the tier with index 4 is the SylPart tier. Printing it, we can see that its superset class has been set to OnsetRime and its subset class has been set to Phone.\n\nprint(spritely[0][4])\n\nSequence tier of SylPart; .superset_class: OnsetRime; .subset_class: Phone\n\n\nWe can look at the labels for this tier:\n\nprint(spritely[0][4].labels)\n\n['', 'Onset', 'Nucleus', 'Coda', 'Onset', 'Nucleus', '']\n\n\nAnd we can print out some information about the index 1 interval.\n\nprint(spritely[0][4][1].label)\nprint(spritely[0][4][1].sub_labels)\n\nOnset\n['S', 'P', 'R']\n\n\n\n\nWhen the tier order != the hierarchy order\nIt’s possible that you’ll be working with textgrids where the largest superset is not the topmost tier. For example, here is the spritely textgrid reversed.\n\n\n\nspritely reversed\n\n\nThe custom_classes() function still needs the hierarchy to be arranged from left to right, but you can also specify a return_order, either by numeric index or by name, that the new classes get returned.\n\ncustom_classes(\n    class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"],\n    return_order=[5, 4, 3, 2, 1, 0]\n)\n# -or-\n# custom_classes(\n#     class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"],\n#     return_order=[\"Phone\", \"SylPart\", \"OnsetRime\", \"Syl\", \"Foot\", \"PrWord\"]\n# )\n\n[aligned_textgrid.custom_classes.Phone,\n aligned_textgrid.custom_classes.SylPart,\n aligned_textgrid.custom_classes.OnsetRime,\n aligned_textgrid.custom_classes.Syl,\n aligned_textgrid.custom_classes.Foot,\n aligned_textgrid.custom_classes.PrWord]\n\n\nThe order of these classes in the output list may have Phone first, but the topmost class in the hierarchy is still PrWord\n\nspritely_rev = AlignedTextGrid(\n    textgrid_path= \"../resources/spritely_rev.TextGrid\",\n    entry_classes = custom_classes(\n        class_list = [\"PrWord\", \"Foot\", \"Syl\", \"OnsetRime\", \"SylPart\", \"Phone\"],\n        return_order=[5, 4, 3, 2, 1, 0]        \n    )\n)\nprint(spritely_rev)\n\nAlignedTextGrid with 1 groups, each with [6] tiers. [['PrWord', 'Foot', 'Syl', 'OnsetRime', 'SylPart', 'Phone']]"
  },
  {
    "objectID": "usage/03_Custom_Classes/index.html#customizing-subclasses",
    "href": "usage/03_Custom_Classes/index.html#customizing-subclasses",
    "title": "Customizing Sequence Interval Classes",
    "section": "Customizing Subclasses",
    "text": "Customizing Subclasses\nThe classes generated by custom_classes() have only the default attributes and methods available within SequenceInterval. If you want any more customized methods or attributes within a sequence interval, you’ll need to create the subclass yourself. For example, let’s say you wanted to create a custom MyWord, Syllable, SyllablePieces, MyPhone classes, where the Syllable class had as an attribute .has_onset, and .open_syllable. The goal parsing for a word like “sprinted” is illustrated below.\n\n\n\nsprinted\n\n\n\nThe minimal requirements\nThe minimal requirements for a custom class are:\n\nIt is a subclass of SequenceInterval.\nEither its .superset_class has been set with .set_superset_class, or its .subset_class has been set with .set_subset_class.\n\n\nSubclassing SequenceInterval\nHere’s the minimal setup to create a sequence interval subclass.\n\nclass MyWord(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\nTo test your new subclass, you’ll have to import Interval from praatio.\n\nfrom praatio.utilities.constants import Interval\n\nMyWord(Interval(0, 1, \"test\"))\n\nClass MyWord, label: test, .superset_class: Top, .super_instance, None, .subset_class: Bottom\n\n\nAs you can see, MyWord has defaulted to have Top as its superset class and Bottom as its subset class. We’ll reset these after creating the remaining subclasses. Both SyllablePart and MyPhone will be created the exact same way as MyWord, since we’re just using the sequence interval defaults for them.\n\nclass SyllablePart(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\nclass MyPhone(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\nFor the specialized properties of Syllable, we’ll start the subclassing the same, but add some properties that return True or False for whether or not the syllable has an onset or a coda.\n\nclass Syllable(SequenceInterval):\n    def __init__(self, Interval):\n        super().__init__(Interval)\n\n    @property\n    def has_onset(self):\n        return \"O\" in self.sub_labels\n    \n    @property\n    def open_syllable(self):\n        return \"C\" not in self.sub_labels\n\nNow, after parsing a properly constructed TextGrid, any instance of the syllable class will return True if “O” is in its subset labels (has an onset), and will return True if “C” is not in its subset labels (does not have a coda).\n\n\nSetting subset and superset classes.\nWe can now set the superset_class and subset_class relationships. These relationships are symmetrical, so we actually only need to set one or the other.\n\nMyWord.set_subset_class(Syllable)\nSyllable.set_subset_class(SyllablePart)\nSyllablePart.set_subset_class(MyPhone)\n\nWe can double check the superset classes have been correctly set.\n\nMyPhone.superset_class\n\n__main__.SyllablePart\n\n\n\nSyllablePart.superset_class\n\n__main__.Syllable\n\n\n\nSyllable.superset_class\n\n__main__.MyWord"
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html",
    "href": "usage/02_Sequences/02_sequence_properties.html",
    "title": "Sequence Interval Properties",
    "section": "",
    "text": "Let’s begin with this textgrid.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\ndog = the_dog.tier_groups[0].tier_list[0].sequence_list[1]"
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#the-behavior-of-len-in-and-iteration",
    "href": "usage/02_Sequences/02_sequence_properties.html#the-behavior-of-len-in-and-iteration",
    "title": "Sequence Interval Properties",
    "section": "The behavior of len(), in and iteration",
    "text": "The behavior of len(), in and iteration\n\nlen()\nIf you pass a Sequence Interval to len(), it’ll return the length of its .subset_list.\n\n\n\nSequence in\n\n\n\nlen(dog)\n\n3\n\n\nIf a Sequence Interval doesn’t have a .subset_list, then len() will return 0.\n\nlen(AH0)\n\n0\n\n\n\n\nin\nIf you want to check whether a specific sequence interval (the actual object, not just the label) is in the .subset_list of another, you can use in.\n\n\n\nSequence in\n\n\n\nAO1 = dog[1]\nAO1 in dog\n\nTrue\n\n\n\nAH0 in dog\n\nFalse\n\n\n\n\nIteration\nA Sequence Interval is iterable over its .subset_list\n\n\n\nsequence iter\n\n\n\nfor segment in dog:\n    print(f\"{segment.label} is in {segment.inword.label}\")\n\nD is in dog\nAO1 is in dog\nG is in dog"
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#subset-sequence-information",
    "href": "usage/02_Sequences/02_sequence_properties.html#subset-sequence-information",
    "title": "Sequence Interval Properties",
    "section": "Subset Sequence Information",
    "text": "Subset Sequence Information\nIn addition to the .start, .end and .label information about each Sequence Interval, if it also has a .subset_list, that same information is accessible with .sub_starts, .sub_ends and .sub_labels.\n\ndog.sub_starts\n\narray([0.30829161, 0.41950136, 0.83568509])\n\n\n\ndog.sub_ends\n\narray([0.41950136, 0.83568509, 0.96658691])\n\n\n\ndog.sub_labels\n\n['D', 'AO1', 'G']\n\n\nThis is a safe way to check if a general phone label is within a word, since just using in on the sequence interval itself checks against specific Sequence Interval objects.\n\n# the label \"G\" is not a Sequence Interval\n\"G\" in dog\n\nFalse\n\n\n\n\"G\" in dog.sub_labels\n\nTrue"
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#hierarchy-strictness",
    "href": "usage/02_Sequences/02_sequence_properties.html#hierarchy-strictness",
    "title": "Sequence Interval Properties",
    "section": "Hierarchy Strictness",
    "text": "Hierarchy Strictness\nThe hierarchy and precedence structure is very “strict”.\n\nA Sequence Interval a can have no more than one .super_instance\nIf a.super_instance is B, then a is in B.subset_list.\nIf a is in B.subset_list, then it is in no other .subset_list.\nIf a is in B.subset_list, then a.super_instance is B\nIf a is not in B.subset_list, then a.super_instance is not B\nIf a.super_instance is not B, then it is not in B.subset_list\n\nSome examples of relationships that cannot be represented are:\n\n\n\nillicit_1\n\n\n\n\n\nillicit_2\n\n\n\n\n\nillicit_3"
  },
  {
    "objectID": "usage/02_Sequences/02_sequence_properties.html#class-strictness",
    "href": "usage/02_Sequences/02_sequence_properties.html#class-strictness",
    "title": "Sequence Interval Properties",
    "section": "Class Strictness",
    "text": "Class Strictness\nAnother source of strictness is the Sequence Interval class. You can get the class of a specific interval with type()\n\ntype(AH0)\n\naligned_textgrid.sequences.word_and_phone.Phone\n\n\n\ntype(dog)\n\naligned_textgrid.sequences.word_and_phone.Word\n\n\nA horizontal strictness of classes is that the .fol and .prev Segment Intervals must be of the same class.\n\ntry:\n    dog.set_fol(AH0)\nexcept Exception as exc:\n    print(exc)\n\nFollowing segment must be an instance of Word\n\n\nEach class also defines what its (one and only) .superset_class and .subset_class is. For classes at the top of the hierarchy, there is a reserved Top class, and for classes at the bottom of the hierarchy, there is a reserved Bottom class.\n\nWord.subset_class\n\naligned_textgrid.sequences.word_and_phone.Phone\n\n\n\nWord.superset_class\n\naligned_textgrid.sequences.word_and_phone.Top_wp\n\n\nIf a Sequence Interval isn’t the right class, it can’t be added to another’s .subset_class or set as its .super_instance.\n\ntry:\n    AH0.append_subset_list(AO1)\nexcept Exception as exc:\n    print(exc)\n\nThe subset_class was defined as Bottom_wp, but provided subset_instance was Phone\n\n\n\ntry:\n    AH0.set_super_instance(AO1)\nexcept Exception as exc:\n    print(exc)\n\nThe superset_class was defined as Word, but provided super_instance was Phone"
  },
  {
    "objectID": "usage/02_Sequences/03_sequence-modification.html",
    "href": "usage/02_Sequences/03_sequence-modification.html",
    "title": "Sequence Modification",
    "section": "",
    "text": "Changing the label of a sequence is fairly straightforward. There are also .fuse_leftwards() and .fuse_rightwards() methods.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\n🚨 These sequence modification methods are destructive, and cannot be undone."
  },
  {
    "objectID": "usage/02_Sequences/03_sequence-modification.html#changing-a-sequence-label",
    "href": "usage/02_Sequences/03_sequence-modification.html#changing-a-sequence-label",
    "title": "Sequence Modification",
    "section": "Changing a sequence label",
    "text": "Changing a sequence label\nWe can change the label of a sequence with simple assignment.\n\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\n\n\nAH0.label\n\n'AH0'\n\n\n\nAH0.label = \"IY0\"\nAH0\n\nClass Phone, label: IY0, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp"
  },
  {
    "objectID": "usage/02_Sequences/03_sequence-modification.html#fusing-leftwards-and-rightwards",
    "href": "usage/02_Sequences/03_sequence-modification.html#fusing-leftwards-and-rightwards",
    "title": "Sequence Modification",
    "section": "Fusing Leftwards and Rightwards",
    "text": "Fusing Leftwards and Rightwards\nYou can also merge sequences together with .fuse_leftwards() and .fuse_rightwards()\n\nAH0.fuse_leftwards()\nAH0\n\nClass Phone, label: DH IY0, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp\n\n\nAll of the relevant information and references are updated when this happens.\n\n# precedence is updated\n[AH0.prev.label, AH0.fol.label]\n\n['#', '#']\n\n\n\n# the superset instance is updated\nlen(AH0.inword)\n\n1\n\n\n\nAH0.inword.sub_labels\n\n['DH IY0']\n\n\n\n# the tier is updated\nAH0.intier.labels\n\n['DH IY0', 'D', 'AO1', 'G']\n\n\n\nlen(AH0.intier)\n\n4\n\n\nIf you merge two sequences with subset lists, their subset lists get merged as well.\n\nAH0.inword.fuse_rightwards()\n\n\nAH0.inword.label\n\n'the dog'\n\n\n\nAH0.inword.sub_labels\n\n['DH IY0', 'D', 'AO1', 'G']\n\n\n\nAH0.inword[1]\n\nClass Phone, label: D, .superset_class: Word, .super_instance: the dog, .subset_class: Bottom_wp\n\n\n\nThe fusion label\nBy default, .fuse_leftwards() and .fuse_rightwards() will append the two interval labels together separated by a space. You can adjust this behavior by passing label_fun a fuction that takes two strings as input and returns a single string as output.\n\ndef my_dash_join(left, right):\n    return \"-\".join([left, right])\n\n\nAH0.fol\n\nClass Phone, label: D, .superset_class: Word, .super_instance: the dog, .subset_class: Bottom_wp\n\n\n\nAH0.fuse_rightwards(label_fun=my_dash_join)\n\n\nAH0\n\nClass Phone, label: DH IY0-D, .superset_class: Word, .super_instance: the dog, .subset_class: Bottom_wp"
  },
  {
    "objectID": "usage/02_Sequences/01_sequence-in-tier.html",
    "href": "usage/02_Sequences/01_sequence-in-tier.html",
    "title": "Navigating Sequences in a Tier",
    "section": "",
    "text": "In addition to their hierarchical relationships, sequences also have relationships to the tiers they’re in.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\ndog = the_dog.tier_groups[0].tier_list[0].sequence_list[1]"
  },
  {
    "objectID": "usage/02_Sequences/01_sequence-in-tier.html#accessing-its-tier",
    "href": "usage/02_Sequences/01_sequence-in-tier.html#accessing-its-tier",
    "title": "Navigating Sequences in a Tier",
    "section": "Accessing its tier",
    "text": "Accessing its tier\nFrom a given sequence, we can access its tier with .intier\n\nAH0.intier\n\nSequence tier of Phone; .superset_class: Word; .subset_class: Bottom_wp\n\n\nWe can also get its index within that tier.\n\nAH0.tier_index\n\n1\n\n\nThis allows for tier-level operations. For example, if we wanted to find the phone interval that occurs 0.5 seconds after the end of the current sequence interval, we could do so like this:\n\nsearch_idx = AH0.intier.get_interval_at_time(AH0.end + 0.5)\nAH0.intier[search_idx]\n\nClass Phone, label: AO1, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp"
  },
  {
    "objectID": "usage/02_Sequences/01_sequence-in-tier.html#tier-wise-relationships",
    "href": "usage/02_Sequences/01_sequence-in-tier.html#tier-wise-relationships",
    "title": "Navigating Sequences in a Tier",
    "section": "Tier-wise relationships",
    "text": "Tier-wise relationships\nWhen a sequence interval is at the edge of a subset list (like, say, a phone within a word), its .fol attribute will reference a dummy boundary interval, even if there’s a following interval in its tier.\n\nAH0.fol\n\nClass Phone, label: #, .superset_class: Word, .super_instance, None, .subset_class: Bottom_wp\n\n\n\nAH0.inword.fol[0]\n\nClass Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp\n\n\nHowever, you can access intervals an arbitrary distance away, tierwise, with .get_tierwise()\n\n[AH0.get_tierwise(-1), AH0.get_tierwise(1), AH0.get_tierwise(2)]\n\n[Class Phone, label: DH, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp,\n Class Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp,\n Class Phone, label: AO1, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp]"
  },
  {
    "objectID": "usage/02_Sequences/00_sequence_structure.html",
    "href": "usage/02_Sequences/00_sequence_structure.html",
    "title": "Sequence Navigation",
    "section": "",
    "text": "Let’s say we began with this textgrid and read it in with AlignedTextGrid().\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nthe_dog = AlignedTextGrid(\n    textgrid_path=\"../resources/the_dog.TextGrid\", \n    entry_classes=[Word, Phone]\n    )\nprint(the_dog)\n\nAlignedTextGrid with 1 groups, each with [2] tiers. [['Word', 'Phone']]\nLet’s grab the objects representing the schwa in “the” and the the entire word “dog”.\nAH0 = the_dog.tier_groups[0].tier_list[1].sequence_list[1]\ndog = the_dog.tier_groups[0].tier_list[0].sequence_list[1]\nBoth of these objects have got basic interval information available as attributes, specifically .start, .end and .label.\n[AH0.start, AH0.end, AH0.label]\n\n[0.1827542202196579, 0.308291607646728, 'AH0']\n[dog.start, dog.end, dog.label]\n\n[0.308291607646728, 0.9665869095874072, 'dog']\nFrom within these sequence intervals, we can also access information from the precedence and hierarchical relationships."
  },
  {
    "objectID": "usage/02_Sequences/00_sequence_structure.html#the-precedence-and-hierarchy-structure",
    "href": "usage/02_Sequences/00_sequence_structure.html#the-precedence-and-hierarchy-structure",
    "title": "Sequence Navigation",
    "section": "The Precedence and Hierarchy structure",
    "text": "The Precedence and Hierarchy structure\nHere is a schematic illustration of how each Sequence Interval is related to the others.\n\n\n\nSequence Structure\n\n\n\nWorking with precedence\nFor our AH0 object, we can access its preceding phone with .prev\n\nAH0.prev\n\nClass Phone, label: DH, .superset_class: Word, .super_instance: the, .subset_class: Bottom_wp\n\n\nImportantly, this is the actual preceding Sequence Interval object, so we an access all of it’s interval information like we did for AH0 itself.\n\n[AH0.prev.start, AH0.prev.end, AH0.prev.label]\n\n[0.0, 0.1827542202196579, 'DH']\n\n\nBecause AH0 is the final Sequence Interval within this word, its .fol attribute is a reference to a dummy boundary interval.\n\n[AH0.fol.start, AH0.fol.end, AH0.fol.label]\n\n[None, None, '#']\n\n\nThe dog object from the word tier has the same .prev and .fol methods available.\n\n[dog.prev.start, dog.prev.end, dog.prev.label]\n\n[0.0, 0.308291607646728, 'the']\n\n\n\n[dog.fol.start, dog.fol.end, dog.fol.label]\n\n[None, None, '#']\n\n\n\n\nUsing hierarchy\n\nMoving upwards\nYou can also navigate upwards and downwards with these objects. The most general attribute to get the Sequence Interval above is .super_instance\n\nAH0.super_instance\n\nClass Word, label: the, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['DH', 'AH0']\n\n\nHowever, the Phone class from aligned_textgrid.sequences.word_and_phone also has an .inword attribute for convenience.\n\nAH0.inword\n\nClass Word, label: the, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['DH', 'AH0']\n\n\n\n[AH0.inword.start, AH0.inword.end, AH0.inword.label]\n\n[0.0, 0.308291607646728, 'the']\n\n\n\n\nMoving Downwards\nFrom the dog object, we can navigate downwards with the .subset_list attribute, which returns a list of each phone Sequence Interval.\n\ndog.subset_list\n\n[Class Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp,\n Class Phone, label: AO1, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp,\n Class Phone, label: G, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp]\n\n\nWe can also directly index into the subset list with dog[]\n\n\n\nSequence indexing\n\n\n\ndog[2]\n\nClass Phone, label: G, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp\n\n\n\n[dog[2].start, dog[2].end, dog[2].label]\n\n[0.8356850885224085, 0.9665869095874072, 'G']\n\n\nThere are also special attributes .first and .last to access the first and last sequences within the subset list.\n\n[dog.first.label, dog.last.label]\n\n['D', 'G']\n\n\n\n\n\nMoving all around\nSince each of these attributes (.prev, .fol, .inword and .subset_list) returns the actual Sequence Interval objects, we can chain them together to create a path through the hierarchy. For example, we can see that AH0 is the final phone in its word.\n\nAH0.fol.label\n\n'#'\n\n\nTo get the label of the first phone of the following word, we can move up to .inword, over one with .fol and then index down into the subset list with .first.\n\n\n\nhierarchy path\n\n\nThere is an easier way to do this with tier references. This example is just to illustrate how a path can be constructed\n\nAH0.inword.fol.first\n\nClass Phone, label: D, .superset_class: Word, .super_instance: dog, .subset_class: Bottom_wp"
  },
  {
    "objectID": "usage/index.html",
    "href": "usage/index.html",
    "title": "Quickstart",
    "section": "",
    "text": "The goal of this package is to make the hierarchical and precedence relationships in TextGrids produced by forced alignment accessable and leverageable for analysis or recoding. You can find a quickstart for reading in a TextGrid on this page."
  },
  {
    "objectID": "usage/index.html#reading-in-a-single-speaker-textgrid",
    "href": "usage/index.html#reading-in-a-single-speaker-textgrid",
    "title": "Quickstart",
    "section": "Reading in a single speaker TextGrid",
    "text": "Reading in a single speaker TextGrid\nTo quickly read in 2 tiered textgrid, like those produced by the Montreal Forced Aligner, import the AlignedTextGrid class and the Word and Phone interval classes.\n\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone\n\nAlignedTextGrid can take either a textgrid_path argument, or a textgrid argument for Textgrid objects that have already been created with praatio.\n\nreading_passage = AlignedTextGrid(\n    textgrid_path = \"resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\nreading_passage\n\nAlignedTextGrid with 1 groups, each with [2] tiers. [['Word', 'Phone']]\n\n\nA list of each tier is available at index 0.\n\nreading_passage[0]\n\nTierGroup with 2 tiers. ['Word', 'Phone']\n\n\nYou can access the specific tiers within a TierGroup with the name of the entry class.\n\nreading_passage[0].Word\n\nSequence tier of Word; .superset_class: Top_wp; .subset_class: Phone"
  },
  {
    "objectID": "usage/index.html#multi-talker-textgrids",
    "href": "usage/index.html#multi-talker-textgrids",
    "title": "Quickstart",
    "section": "Multi-talker TextGrids",
    "text": "Multi-talker TextGrids\nTo read in a multi-talker textgrid, with the same Word,Phone organization for each speaker, the same approach works.\n\ntwo_speaker = AlignedTextGrid(\n    textgrid_path = \"resources/KY25A_1.TextGrid\",\n    entry_classes=[Word, Phone]\n)\ntwo_speaker\n\nAlignedTextGrid with 2 groups, each with [2, 2] tiers. [['Word', 'Phone'], ['Word', 'Phone']]\n\n\nThe first speakers’ tiers are available at index 0, and the second speakers tiers are available at index 1.\n\ntwo_speaker[0]\n\nTierGroup with 2 tiers. ['Word', 'Phone']\n\n\n\ntwo_speaker[1]\n\nTierGroup with 2 tiers. ['Word', 'Phone']"
  },
  {
    "objectID": "usage/index.html#accessing-intervals",
    "href": "usage/index.html#accessing-intervals",
    "title": "Quickstart",
    "section": "Accessing intervals",
    "text": "Accessing intervals\nYou can access intervals within a tier via ordinary indexing, looping, list comprehensions, etc.\n\nfor word in two_speaker[0].Word:\n    print(word.label)\n\n\nyeah\n\nwell\nnow\n\nyou\n\nmight\n\nstart\nthat\n\ni\nwas\nborn\nin\n\neighteen\nsixty\nseven\n\nnintey\nthree"
  },
  {
    "objectID": "usage/05_Outputs/01_to_dataframe.html",
    "href": "usage/05_Outputs/01_to_dataframe.html",
    "title": "Outputting and saving as a DataFrame",
    "section": "",
    "text": "You can ouput and save any given aligned_textgrid as a polars dataframe with the to_df() function."
  },
  {
    "objectID": "usage/05_Outputs/01_to_dataframe.html#outputting-as-a-data-frame",
    "href": "usage/05_Outputs/01_to_dataframe.html#outputting-as-a-data-frame",
    "title": "Outputting and saving as a DataFrame",
    "section": "Outputting as a data frame",
    "text": "Outputting as a data frame\n\nimport polars as pl\n\nfrom aligned_textgrid import AlignedTextGrid, Word, Phone,\\\n                             to_df\n\ntg = AlignedTextGrid(\n    textgrid_path=\"../resources/josef-fruehwald_speaker.TextGrid\",\n    entry_classes=[Word, Phone]\n)\n\n\nSingle Intervals\n\nBottom of the hierarchy\nIf you pass a single interval from the bottom of the sequence hierarchy, you’ll get back a fairly minimal dataframe with the start and end times, the label, and an ID for the interval.\n\none_interval = tg[0].Phone[1]\none_interval_df = to_df(one_interval)\n\none_interval_df\n\n\nshape: (1, 5)\n\n\n\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\n\n\n\n\n\nTop of the hierarchy\nIf you pass to_df() an interval from higher up in the hierarchy, by default it will output its data, as well as the data for every interval below it in the hierarchy, concatenated horizontally.\n\nword_interval = tg[0].Word[1]\nword_interval_df = to_df(word_interval)\n\nword_interval_df\n\n\nshape: (4, 10)\n\n\n\nWord_id\nWord_tier_index\nWord_label\nWord_start\nWord_end\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-1\"\n2\n\"W\"\n1.97\n2.09\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-2\"\n3\n\"EH1\"\n2.09\n2.13\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-3\"\n4\n\"N\"\n2.13\n2.2\n\n\n\n\n\n\nHowever, if you want just a simplified, single row output for an interval, regardless of its location within the hierarchy, pass to_df(..., with_subset = False).\n\nword_interval_df2 = to_df(word_interval, with_subset=False)\n\nword_interval_df2\n\n\nshape: (1, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"Word\"\n\n\n\n\n\n\n\n\n\nTiers\nIf you pass a tier to to_df(), it will output a dataframe for ever interval in the tier concatenated vertically. By default, this means intervals high in the hierarchy will have their rows repeated for every interval they contain, but if you want one row per interval in the output, you can pass to_df(..., with_subset = False).\n\ntier_df1 = to_df(tg[0].Word)\n\ntier_df1.shape\n\n(1191, 10)\n\n\n\ntier_df1.head(10)\n\n\nshape: (10, 10)\n\n\n\nWord_id\nWord_tier_index\nWord_label\nWord_start\nWord_end\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"0-0-0-0\"\n0\n\"\"\n0.0\n0.11\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-1\"\n2\n\"W\"\n1.97\n2.09\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-2\"\n3\n\"EH1\"\n2.09\n2.13\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-3\"\n4\n\"N\"\n2.13\n2.2\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-0\"\n5\n\"DH\"\n2.2\n2.22\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-1\"\n6\n\"AH0\"\n2.22\n2.26\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-0\"\n7\n\"S\"\n2.26\n2.39\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-1\"\n8\n\"AH1\"\n2.39\n2.44\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-2\"\n9\n\"N\"\n2.44\n2.52\n\n\n\n\n\n\n\n# 1 row per interval\ntier_df2 = to_df(tg[0].Word, with_subset=False)\n\ntier_df2.shape\n\n(377, 6)\n\n\n\ntier_df2.head(10)\n\n\nshape: (10, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"Word\"\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"Word\"\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"Word\"\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"Word\"\n\n\n\"0-0-4\"\n4\n\"strikes\"\n2.72\n3.22\n\"Word\"\n\n\n\"0-0-5\"\n5\n\"raindrops\"\n3.22\n3.79\n\"Word\"\n\n\n\"0-0-6\"\n6\n\"in\"\n3.79\n3.89\n\"Word\"\n\n\n\"0-0-7\"\n7\n\"the\"\n3.89\n4.02\n\"Word\"\n\n\n\"0-0-8\"\n8\n\"air\"\n4.02\n4.45\n\"Word\"\n\n\n\"0-0-9\"\n9\n\"\"\n4.45\n4.61\n\"Word\"\n\n\n\n\n\n\n\n\nTierGroups and TextGrids\nThe behavior for TierGroups and TextGrids are similar. By default, the to_df() function will either return a dataframe representing the entire hierarchy structure, or will return one row for each interval in the TextGrid.\n\nfull_df1 = to_df(tg)\n\nfull_df1.shape\n\n(1191, 10)\n\n\n\nfull_df1.head(10)\n\n\nshape: (10, 10)\n\n\n\nWord_id\nWord_tier_index\nWord_label\nWord_start\nWord_end\nPhone_id\nPhone_tier_index\nPhone_label\nPhone_start\nPhone_end\n\n\nstr\ni64\nstr\nf64\nf64\nstr\ni64\nstr\nf64\nf64\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"0-0-0-0\"\n0\n\"\"\n0.0\n0.11\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-0\"\n1\n\"HH\"\n0.11\n1.97\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-1\"\n2\n\"W\"\n1.97\n2.09\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-2\"\n3\n\"EH1\"\n2.09\n2.13\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"0-0-1-3\"\n4\n\"N\"\n2.13\n2.2\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-0\"\n5\n\"DH\"\n2.2\n2.22\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"0-0-2-1\"\n6\n\"AH0\"\n2.22\n2.26\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-0\"\n7\n\"S\"\n2.26\n2.39\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-1\"\n8\n\"AH1\"\n2.39\n2.44\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"0-0-3-2\"\n9\n\"N\"\n2.44\n2.52\n\n\n\n\n\n\n\n# 1 row per interval\nfull_df2 = to_df(tg, with_subset=False)\n\nfull_df2.shape\n\n(1568, 6)\n\n\n\nfull_df2.head(5)\n\n\nshape: (5, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-0\"\n0\n\"\"\n0.0\n0.11\n\"Word\"\n\n\n\"0-0-1\"\n1\n\"when\"\n0.11\n2.2\n\"Word\"\n\n\n\"0-0-2\"\n2\n\"the\"\n2.2\n2.26\n\"Word\"\n\n\n\"0-0-3\"\n3\n\"sunlight\"\n2.26\n2.72\n\"Word\"\n\n\n\"0-0-4\"\n4\n\"strikes\"\n2.72\n3.22\n\"Word\"\n\n\n\n\n\n\n\nfull_df2.tail(5)\n\n\nshape: (5, 6)\n\n\n\nid\ntier_index\nlabel\nstart\nend\nentry_class\n\n\nstr\ni64\nstr\nf64\nf64\nstr\n\n\n\n\n\"0-0-374-1\"\n1186\n\"R\"\n111.83\n111.92\n\"Phone\"\n\n\n\"0-0-375-0\"\n1187\n\"B\"\n111.92\n112.02\n\"Phone\"\n\n\n\"0-0-375-1\"\n1188\n\"L\"\n112.02\n112.08\n\"Phone\"\n\n\n\"0-0-375-2\"\n1189\n\"UW1\"\n112.08\n112.31\n\"Phone\"\n\n\n\"0-0-376-0\"\n1190\n\"\"\n112.31\n115.065034\n\"Phone\""
  },
  {
    "objectID": "usage/05_Outputs/01_to_dataframe.html#saving-a-dataframe",
    "href": "usage/05_Outputs/01_to_dataframe.html#saving-a-dataframe",
    "title": "Outputting and saving as a DataFrame",
    "section": "Saving a DataFrame",
    "text": "Saving a DataFrame\nTo save one of these dataframes, use one of the methods from polars, like DataFrame.write_csv()\n\nfull_df1.write_csv(\"test.csv\")"
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html",
    "href": "usage/01_TextGrids/01_tg-nav.html",
    "title": "Navigating an AlignedTextGrid",
    "section": "",
    "text": "This documentation covers reading in the output from the Montreal Forced Aligner using the Word and Phone classes from aligned_textgrid, but everything will generalize to custom classes.\nfrom aligned_textgrid import AlignedTextGrid\nfrom aligned_textgrid import Word, Phone"
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html#reading-in-a-textgrid",
    "href": "usage/01_TextGrids/01_tg-nav.html#reading-in-a-textgrid",
    "title": "Navigating an AlignedTextGrid",
    "section": "Reading in a TextGrid",
    "text": "Reading in a TextGrid\nTo read in a one-speaker TextGrid, either give AlignedTextGrid() the path to the file, or a textgrid that has already been read in with praatio.textgrid.openTextgrid().\nYou also need to specify the sequence classes of each tier in the order they appear. For MFA output, the top tier is Word and the bottom tier is Phone, but if these were reversed, you would have to pass [Phone, Word] to entry_classes. The information about which class is the superset and which is the subset is encoded in the class information, and is automatically handled.\n\none_speaker = AlignedTextGrid(\n    textgrid_path = \"../resources/josef-fruehwald_speaker.TextGrid\", \n    entry_classes = [Word, Phone]\n)\n\nWith a two or more speaker TextGrid, you can either pass entry_classes a single list of interval classes to re-use with each speaker (for example [Word, Phone]), or an explicit list of nested classes (for example, [[Word, Phone], [Word, Phone]]).\n\ntwo_speaker = AlignedTextGrid(\n    textgrid_path = \"../resources/KY25A_1.TextGrid\",\n    entry_classes= [Word, Phone]\n)\n\nIf you have a textgrid a mixture of sequence hierarchies, you have to read it in with then fully nested list of classes.\n\nfrom aligned_textgrid import custom_classes\nTurn = custom_classes(\"Turn\")\n\nmulti_hierarchy = AlignedTextGrid(\n    textgrid_path = \"../resources/KY25A_1_multi.TextGrid\",\n    entry_classes = [[Word, Phone], [Turn], [Word, Phone], [Turn]]\n)\n\nprint(multi_hierarchy)\n\nAlignedTextGrid with 4 groups, each with [2, 1, 2, 1] tiers. [['Word', 'Phone'], ['Turn'], ['Word', 'Phone'], ['Turn']]"
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html#navigating-the-alignedtextgrid-object",
    "href": "usage/01_TextGrids/01_tg-nav.html#navigating-the-alignedtextgrid-object",
    "title": "Navigating an AlignedTextGrid",
    "section": "Navigating the AlignedTextGrid object",
    "text": "Navigating the AlignedTextGrid object\nEvery AlignedTextGrid object contains at least one TierGroup, which in turn contains at least one SequenceTier.\n\n\n\naligned-textgrid\n\n\nThis information is available if you print the object:\n\nprint(two_speaker)\n\nAlignedTextGrid with 2 groups, each with [2, 2] tiers. [['Word', 'Phone'], ['Word', 'Phone']]\n\n\nOr if you compare the len() of the one speaker vs two speaker textgrids.”\n\nprint(len(one_speaker))\nprint(len(two_speaker))\n\n1\n2\n\n\nTo get the Word tier of the first speaker in one_speaker, we can index it with [0][0]\n\none_speaker[0][0]\n\nSequence tier of Word; .superset_class: Top_wp; .subset_class: Phone\n\n\nIf you’d prefer to wrote more verbose but explicit code, you can also access tiers via the .tier_groups and .tier_list attributes as well.\n\none_speaker.tier_groups[0].tier_list[0]\n\nSequence tier of Word; .superset_class: Top_wp; .subset_class: Phone\n\n\nTo access the individual sequence intervals in a tier, you can also use indexing.\n\none_speaker[0][0][3]\n\nClass Word, label: sunlight, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['S', 'AH1', 'N', 'L', 'AY2', 'T']\n\n\nTiers are also iterable.\n\nfor i in range(5):\n    print(one_speaker[0][0][i].label)\n\n\nwhen\nthe\nsunlight\nstrikes\n\n\nOnce you’ve gotten to a sequence interval, indexing goes into its .subset_list\nThe len() of a tier returns how many sequence intervals it constains.\n\n[len(one_speaker[0][0]), len(one_speaker[0][1])]\n\n[377, 1191]"
  },
  {
    "objectID": "usage/01_TextGrids/01_tg-nav.html#get-interval-at-time",
    "href": "usage/01_TextGrids/01_tg-nav.html#get-interval-at-time",
    "title": "Navigating an AlignedTextGrid",
    "section": "Get interval at time",
    "text": "Get interval at time\nThe “Get interval at time” functionality from Praat has been implemented for each level of TextGrid representation.\n\nspeaker_one = two_speaker[0]\nspeaker_one_word = speaker_one[0]\n\n\nspeaker_one_word.get_interval_at_time(11)\n\n1\n\n\nThis is the index for the word that appears at 11 seconds.\n\nspeaker_one.get_intervals_at_time(11)\n\n[1, 2]\n\n\nThese are the indices for the word and phone tiers that are at 11 seconds.\n\ntwo_speaker.get_intervals_at_time(11)\n\n[[1, 2], [39, 96]]\n\n\n\ntwo_speaker.get_intervals_at_time(11)\n\n[[1, 2], [39, 96]]\n\n\nThese are the indices for the word and phone tiers for both speakers at 11 seconds.\n\nNested indexing\nYou can use the nested indices returned by .get_intervals_at_time() to get the actual sequence intervals as well.\n\neleven_seconds = two_speaker.get_intervals_at_time(11)\ntwo_speaker[eleven_seconds]\n\n[[Class Word, label: yeah, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['Y', 'AE1'],\n  Class Phone, label: AE1, .superset_class: Word, .super_instance: yeah, .subset_class: Bottom_wp],\n [Class Word, label: after, .superset_class: Top_wp, .super_instance, None, .subset_class: Phone, .subset_list: ['AE1', 'F', 'T', 'ER0'],\n  Class Phone, label: F, .superset_class: Word, .super_instance: after, .subset_class: Bottom_wp]]"
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html",
    "href": "usage/04_Points/00_points_and_point_tiers.html",
    "title": "Points",
    "section": "",
    "text": "Praat points are represented using the SequencePoint class, which is much less constrained than the SequenceInterval class. They don’t have hierarchical relationships defined, and the same SequencePoint subclass can exist within a single SequencePointTier.\nfrom aligned_textgrid import SequencePoint, SequenceInterval, \\\n    SequenceTier, SequencePointTier, \\\n        AlignedTextGrid\nfrom aligned_textgrid import custom_classes\nTo read in a TextGrid with a mixture of intervals and points (download link), you’ll need to provide both SequenceInterval and SequencePoint entry classes. Both can be created with the custom_classes() function. By default, a list of strings will create SequenceInterval subclasses, but you can add indicies of which classes should be SequencePoint subclasses.\nWord, Phone = custom_classes([\"Word\", \"Phone\"])\nRanges = custom_classes(\"Ranges\")\n\nToBI, PrStr, TurningPoints, Levels = custom_classes(\n    [\"ToBI\", \"PrStr\", \"TurningPoints\", \"Levels\"], \n    points=[0, 1, 2, 3]\n)\nNow you can read in the TextGrid using these custom classes. entry_classes should be a list of list indicating how the tiers are nested (or not.)\ntg = AlignedTextGrid(\n    textgrid_path = \"../resources/amelia_knew2-basic.TextGrid\",\n    entry_classes = [\n        [Word, Phone],\n        [ToBI, PrStr, TurningPoints, Levels],\n        [Ranges]\n    ]\n)\ntg\n\nAlignedTextGrid with 3 groups, each with [2, 4, 1] tiers. [['Word', 'Phone'], ['ToBI', 'PrStr', 'TurningPoints', 'Levels'], ['Ranges']]"
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html#navigating-a-sequencepointtier",
    "href": "usage/04_Points/00_points_and_point_tiers.html#navigating-a-sequencepointtier",
    "title": "Points",
    "section": "Navigating a SequencePointTier",
    "text": "Navigating a SequencePointTier\nMost of the same rules apply to navigating a SequencePointTier as a SequenceTier. Let’s grab the Levels tier for example\n\nlevels_tier = tg[1][3]\n\nEach point in the levels tier can be accessed either by iteration or by indexing.\n\nlevels_tier[0]\n\nClass Levels, label: 2; tier_index: 0\n\n\n\nfor point in levels_tier:\n    print(point)\n\nClass Levels, label: 2; tier_index: 0\nClass Levels, label: 1; tier_index: 1\nClass Levels, label: 5; tier_index: 2\nClass Levels, label: 1; tier_index: 3\nClass Levels, label: 1; tier_index: 4\nClass Levels, label: 3; tier_index: 5\n\n\nThe .fol and .prev relationships are also defined for points.\n\nlevels_tier[1].fol\n\nClass Levels, label: 5; tier_index: 2\n\n\n\nlevels_tier[1].fol.fol\n\nClass Levels, label: 1; tier_index: 3\n\n\n\nlevels_tier[1].prev\n\nClass Levels, label: 2; tier_index: 0"
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepoint-attributes",
    "href": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepoint-attributes",
    "title": "Points",
    "section": "Useful SequencePoint attributes",
    "text": "Useful SequencePoint attributes\nThe most useful attributes of a SequencePoint will be its .label and its .time\n\nexample_point = levels_tier[1]\n\nexample_point.label\n\n'1'\n\n\n\nexample_point.time\n\n0.20235139465888988\n\n\nThe labels and times of all points in a SequencePointTier can be accessed with .labels and .times.\n\n# accessing the parent tier\nexample_point.intier.labels\n\n['2', '1', '5', '1', '1', '3']\n\n\n\nexample_point.intier.times\n\narray([0.08467382, 0.20235139, 0.36102389, 0.51020478, 0.73123339,\n       0.83802   ])\n\n\nThere are also attributes giving the distance between the current point and its .fol and .prev point.\n\nexample_point.fol_distance\n\n0.15867249135026215\n\n\n\nexample_point.prev_distance\n\n-0.11767757671157641"
  },
  {
    "objectID": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepointmethods",
    "href": "usage/04_Points/00_points_and_point_tiers.html#useful-sequencepointmethods",
    "title": "Points",
    "section": "Useful SequencePointMethods",
    "text": "Useful SequencePointMethods\nWith the .get_interval_at_time() method, you can get the interval a point falls within if passed a SequenceTier.\n\nphone_tier = tg[0][1]\n\n\nphone_tier.labels\n\n['', '\\\\sw', 'm', 'i', 'l', 'j', '\\\\sw', 'n', 'u', '\\\\sw', 'm', '']\n\n\n\nexample_point.get_interval_at_point(phone_tier)\n\nClass Phone, label: i, .superset_class: Word, .super_instance: Amelia, .subset_class: Bottom_1\n\n\nIf passed any given SequenceInterval or SequencePoint, the .distance_from() method will give the distance from the current point.\n\nexample_interval = example_point.get_interval_at_point(phone_tier)\n\nexample_point.distance_from(example_interval)\n\narray([ 0.01603854, -0.11062785])\n\n\n\nexample_point.distance_from(example_interval.fol)\n\narray([-0.11062785, -0.18968809])"
  },
  {
    "objectID": "reference/TurningPoints.html",
    "href": "reference/TurningPoints.html",
    "title": "TurningPoints",
    "section": "",
    "text": "polar.polar_classes.TurningPoints(self, Point)\nA turning point class\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint\n\n\nlevel\nLevels\nThe Levels point associated with this turning point\n\n\ncertainty\nstr\nIf a ‘?’ was appended to a point label, 'uncertain', otherwise 'certain'\n\n\noverride\nstr\nAn override value, if provided"
  },
  {
    "objectID": "reference/TurningPoints.html#attributes",
    "href": "reference/TurningPoints.html#attributes",
    "title": "TurningPoints",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint\n\n\nlevel\nLevels\nThe Levels point associated with this turning point\n\n\ncertainty\nstr\nIf a ‘?’ was appended to a point label, 'uncertain', otherwise 'certain'\n\n\noverride\nstr\nAn override value, if provided"
  },
  {
    "objectID": "reference/TierGroupMixins.html",
    "href": "reference/TierGroupMixins.html",
    "title": "TierGroupMixins",
    "section": "",
    "text": "mixins.tiermixins.TierGroupMixins()\nMethods and attributes for grouped tiers\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n[]\n\nIndexable and iterable"
  },
  {
    "objectID": "reference/TierGroupMixins.html#attributes",
    "href": "reference/TierGroupMixins.html#attributes",
    "title": "TierGroupMixins",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n[]\n\nIndexable and iterable"
  },
  {
    "objectID": "reference/to_df.html",
    "href": "reference/to_df.html",
    "title": "to_df",
    "section": "",
    "text": "outputs.to_dataframe.to_df(obj, with_subset=True)\nReturn an aligned_textgrid object as a dataframe\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nobj\nSequenceInterval | SequencePoint | SequenceTier | SequencePointTier | TierGroup | PointsGroup | AlignedTextGrid\nAn aligned_textgrid object\nrequired\n\n\nwith_subset\nbool\nWhether or not to include subset relationships. Defaults to True.\nTrue\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npl.DataFrame\nA polars dataframe"
  },
  {
    "objectID": "reference/to_df.html#parameters",
    "href": "reference/to_df.html#parameters",
    "title": "to_df",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nobj\nSequenceInterval | SequencePoint | SequenceTier | SequencePointTier | TierGroup | PointsGroup | AlignedTextGrid\nAn aligned_textgrid object\nrequired\n\n\nwith_subset\nbool\nWhether or not to include subset relationships. Defaults to True.\nTrue"
  },
  {
    "objectID": "reference/to_df.html#returns",
    "href": "reference/to_df.html#returns",
    "title": "to_df",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\npl.DataFrame\nA polars dataframe"
  },
  {
    "objectID": "reference/PrecedenceMixins.html",
    "href": "reference/PrecedenceMixins.html",
    "title": "PrecedenceMixins",
    "section": "",
    "text": "mixins.mixins.PrecedenceMixins()\nMethods and attributes for SequenceIntervals and SequencePoints\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nfirst\nSequenceInterval\nThe first interval in the subset list\n\n\nlast\nSequenceInterval\nThe last interval in the subset list\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nset_final\nSets the current object as having no fol entry\n\n\nset_fol\nSets the following instance\n\n\nset_initial\nSets the current object as having no prev entry\n\n\nset_prev\nSets the previous intance\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_final()\nSets the current object as having no fol entry\nWhile self.fol is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_fol(next_int)\nSets the following instance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnext_int\nSequenceInterval | SequencePoint\nSets the next_int as the fol entry. Must be of the same class as the current object. That is, type(next_int) is type(self)\nrequired\n\n\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_initial()\nSets the current object as having no prev entry\nWhile self.prev is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_prev(prev_int)\nSets the previous intance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprev_int\nSequenceInterval | SequencePoint\nSets the prev_int as the prev entry. Must be of the same class as the current object. That is, type(prev_int) is type(self)\nrequired"
  },
  {
    "objectID": "reference/PrecedenceMixins.html#attributes",
    "href": "reference/PrecedenceMixins.html#attributes",
    "title": "PrecedenceMixins",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nfirst\nSequenceInterval\nThe first interval in the subset list\n\n\nlast\nSequenceInterval\nThe last interval in the subset list"
  },
  {
    "objectID": "reference/PrecedenceMixins.html#methods",
    "href": "reference/PrecedenceMixins.html#methods",
    "title": "PrecedenceMixins",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nset_final\nSets the current object as having no fol entry\n\n\nset_fol\nSets the following instance\n\n\nset_initial\nSets the current object as having no prev entry\n\n\nset_prev\nSets the previous intance\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_final()\nSets the current object as having no fol entry\nWhile self.fol is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_fol(next_int)\nSets the following instance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnext_int\nSequenceInterval | SequencePoint\nSets the next_int as the fol entry. Must be of the same class as the current object. That is, type(next_int) is type(self)\nrequired\n\n\n\n\n\n\n\nmixins.mixins.PrecedenceMixins.set_initial()\nSets the current object as having no prev entry\nWhile self.prev is defined for these entries, the actual instance does not appear in self.super_instance.subset_list\n\n\n\nmixins.mixins.PrecedenceMixins.set_prev(prev_int)\nSets the previous intance\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprev_int\nSequenceInterval | SequencePoint\nSets the prev_int as the prev entry. Must be of the same class as the current object. That is, type(prev_int) is type(self)\nrequired"
  },
  {
    "objectID": "reference/SequencePointTier.html",
    "href": "reference/SequencePointTier.html",
    "title": "SequencePointTier",
    "section": "",
    "text": "points.tiers.SequencePointTier(self, tier=[], entry_class=SequencePoint)\nA SequencePointTier class\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nPointTier | list[Point]\nEither a praatio PointTier or a list of praatio Points\n[]\n\n\nentry_class\nType[SequencePoint]\nA SequencePoint subclass\nSequencePoint\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n…\n\nAll attributes and methods included in TierMixins\n\n\nentry_class\nType[SequencePoint]\nThe class of entries within the tier\n\n\nname\nstr\nThe name of the tier\n\n\ntimes\nnp.array\nThe times of points in the tier\n\n\nlabels\nlist[str, …]\nThe labels of points in the tier\n\n\nxmin\nfloat\nThe time of the first point in the tier\n\n\nxmax\nfloat\nThe time of the last point in the tier\n\n\n[]\nfloat\nIndexable and iterable\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_nearest_point\nReturns nearest point\n\n\nget_nearest_point_index\nReturns the index of the closest point to time\n\n\nreturn_tier\nReturns SequencePointTier as a praatio PointTier\n\n\nsave_as_tg\nSaves the current point tier as a textgrid\n\n\n\n\n\npoints.tiers.SequencePointTier.get_nearest_point(time)\nReturns nearest point\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime at which to get the nearest point\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequencePoint\nthe nearest point to time\n\n\n\n\n\n\n\npoints.tiers.SequencePointTier.get_nearest_point_index(time)\nReturns the index of the closest point to time\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\nThe time at which to get the nearest point\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the nearest point within the tier\n\n\n\n\n\n\n\npoints.tiers.SequencePointTier.return_tier()\nReturns SequencePointTier as a praatio PointTier\n\n\n\n\n\nType\nDescription\n\n\n\n\nPointTier\nA praatio point tier\n\n\n\n\n\n\n\npoints.tiers.SequencePointTier.save_as_tg(save_path)\nSaves the current point tier as a textgrid\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\npath to where you want to save the textgrid.\nrequired"
  },
  {
    "objectID": "reference/SequencePointTier.html#parameters",
    "href": "reference/SequencePointTier.html#parameters",
    "title": "SequencePointTier",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntier\nPointTier | list[Point]\nEither a praatio PointTier or a list of praatio Points\n[]\n\n\nentry_class\nType[SequencePoint]\nA SequencePoint subclass\nSequencePoint"
  },
  {
    "objectID": "reference/SequencePointTier.html#attributes",
    "href": "reference/SequencePointTier.html#attributes",
    "title": "SequencePointTier",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n…\n\nAll attributes and methods included in TierMixins\n\n\nentry_class\nType[SequencePoint]\nThe class of entries within the tier\n\n\nname\nstr\nThe name of the tier\n\n\ntimes\nnp.array\nThe times of points in the tier\n\n\nlabels\nlist[str, …]\nThe labels of points in the tier\n\n\nxmin\nfloat\nThe time of the first point in the tier\n\n\nxmax\nfloat\nThe time of the last point in the tier\n\n\n[]\nfloat\nIndexable and iterable"
  },
  {
    "objectID": "reference/SequencePointTier.html#methods",
    "href": "reference/SequencePointTier.html#methods",
    "title": "SequencePointTier",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_nearest_point\nReturns nearest point\n\n\nget_nearest_point_index\nReturns the index of the closest point to time\n\n\nreturn_tier\nReturns SequencePointTier as a praatio PointTier\n\n\nsave_as_tg\nSaves the current point tier as a textgrid\n\n\n\n\n\npoints.tiers.SequencePointTier.get_nearest_point(time)\nReturns nearest point\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime at which to get the nearest point\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequencePoint\nthe nearest point to time\n\n\n\n\n\n\n\npoints.tiers.SequencePointTier.get_nearest_point_index(time)\nReturns the index of the closest point to time\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\nThe time at which to get the nearest point\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the nearest point within the tier\n\n\n\n\n\n\n\npoints.tiers.SequencePointTier.return_tier()\nReturns SequencePointTier as a praatio PointTier\n\n\n\n\n\nType\nDescription\n\n\n\n\nPointTier\nA praatio point tier\n\n\n\n\n\n\n\npoints.tiers.SequencePointTier.save_as_tg(save_path)\nSaves the current point tier as a textgrid\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\npath to where you want to save the textgrid.\nrequired"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Function reference",
    "section": "",
    "text": "These classes define attributes and methods for Intervals and Points.\n\n\nThese classes define common attributes and methods available to intervals and points.\n\n\n\nPrecedenceMixins\nMethods and attributes for SequenceIntervals and SequencePoints\n\n\nInTierMixins\nMethods and attrubites relating Sequence* objects to tiers.\n\n\n\n\n\n\nThe basic SequenceInterval class and special Top and Bottom classes. For customized SequenceIntervals, see Word and Phone, or custom_classes().\n\n\n\nSequenceInterval\nA class to describe an interval with precedence relationships and hierarchical relationships\n\n\nTop\nA top level interval class\n\n\nBottom\nA bottom level interval class\n\n\n\n\n\n\nThere is just a single SequencePoint class, since points don’t have hierarchical relationships defined.\n\n\n\nSequencePoint\nSequence Points\n\n\n\n\n\n\n\nTiers Classes\n\n\nThese classes define common attributes and methods shared accross all tier and tiergroups.\n\n\n\nTierMixins\nMethods and attributes for Sequence Tiers\n\n\nTierGroupMixins\nMethods and attributes for grouped tiers\n\n\n\n\n\n\nThese classes define tiers and tier groups.\n\n\n\nSequenceTier\nA sequence tier\n\n\nSequencePointTier\nA SequencePointTier class\n\n\nTierGroup\nTier Grouping\n\n\n\n\n\n\n\nTextGrid Classes\n\n\n\nAlignedTextGrid\nAn aligned Textgrid\n\n\n\n\n\n\nCustom Classes\n\n\nThis is a function that will quickly create custom classes - package: aligned_textgrid.custom_classes name: custom_classes\n\n\n\nThese are mostly intended to be used with textgrids that are the product of forced alignment.\n\n\n\nWord\nA Word subclass of SequenceInterval\n\n\nPhone\nA Phone subclass of SequenceInterval\n\n\n\n\n\n\nThese are classes intended to make it easier to work with PoLaR annotation.\n\n\n\nPrStr\nPrStr tier points\n\n\nToBI\nA ToBI point class\n\n\nToBI\nA ToBI point class\n\n\nTurningPoints\nA turning point class\n\n\nRanges\nA ranges interval\n\n\nLevels\nA levels point class\n\n\nMisc\nMisc points\n\n\n\n\n\n\n\nThis will return a polars dataframe given an aligned_textgrid object\n\n\n\nto_df\nReturn an aligned_textgrid object as a dataframe"
  },
  {
    "objectID": "reference/index.html#sequence-classes",
    "href": "reference/index.html#sequence-classes",
    "title": "Function reference",
    "section": "",
    "text": "These classes define attributes and methods for Intervals and Points.\n\n\nThese classes define common attributes and methods available to intervals and points.\n\n\n\nPrecedenceMixins\nMethods and attributes for SequenceIntervals and SequencePoints\n\n\nInTierMixins\nMethods and attrubites relating Sequence* objects to tiers.\n\n\n\n\n\n\nThe basic SequenceInterval class and special Top and Bottom classes. For customized SequenceIntervals, see Word and Phone, or custom_classes().\n\n\n\nSequenceInterval\nA class to describe an interval with precedence relationships and hierarchical relationships\n\n\nTop\nA top level interval class\n\n\nBottom\nA bottom level interval class\n\n\n\n\n\n\nThere is just a single SequencePoint class, since points don’t have hierarchical relationships defined.\n\n\n\nSequencePoint\nSequence Points"
  },
  {
    "objectID": "reference/index.html#tiers",
    "href": "reference/index.html#tiers",
    "title": "Function reference",
    "section": "",
    "text": "Tiers Classes\n\n\nThese classes define common attributes and methods shared accross all tier and tiergroups.\n\n\n\nTierMixins\nMethods and attributes for Sequence Tiers\n\n\nTierGroupMixins\nMethods and attributes for grouped tiers\n\n\n\n\n\n\nThese classes define tiers and tier groups.\n\n\n\nSequenceTier\nA sequence tier\n\n\nSequencePointTier\nA SequencePointTier class\n\n\nTierGroup\nTier Grouping"
  },
  {
    "objectID": "reference/index.html#textgrids",
    "href": "reference/index.html#textgrids",
    "title": "Function reference",
    "section": "",
    "text": "TextGrid Classes\n\n\n\nAlignedTextGrid\nAn aligned Textgrid"
  },
  {
    "objectID": "reference/index.html#custom-classes",
    "href": "reference/index.html#custom-classes",
    "title": "Function reference",
    "section": "",
    "text": "Custom Classes\n\n\nThis is a function that will quickly create custom classes - package: aligned_textgrid.custom_classes name: custom_classes\n\n\n\nThese are mostly intended to be used with textgrids that are the product of forced alignment.\n\n\n\nWord\nA Word subclass of SequenceInterval\n\n\nPhone\nA Phone subclass of SequenceInterval\n\n\n\n\n\n\nThese are classes intended to make it easier to work with PoLaR annotation.\n\n\n\nPrStr\nPrStr tier points\n\n\nToBI\nA ToBI point class\n\n\nToBI\nA ToBI point class\n\n\nTurningPoints\nA turning point class\n\n\nRanges\nA ranges interval\n\n\nLevels\nA levels point class\n\n\nMisc\nMisc points"
  },
  {
    "objectID": "reference/index.html#dataframe-outputs",
    "href": "reference/index.html#dataframe-outputs",
    "title": "Function reference",
    "section": "",
    "text": "This will return a polars dataframe given an aligned_textgrid object\n\n\n\nto_df\nReturn an aligned_textgrid object as a dataframe"
  },
  {
    "objectID": "reference/TierGroup.html",
    "href": "reference/TierGroup.html",
    "title": "TierGroup",
    "section": "",
    "text": "sequences.tiers.TierGroup(self, tiers=[SequenceTier()])\nTier Grouping\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntiers\nlist[SequenceTier]\nA list of sequence tiers that are meant to be in hierarchical relationships with eachother\n[SequenceTier()]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntier_list\nlist[SequenceTier]\nList of sequence tiers that have been related.\n\n\nentry_classes\nlist[Type[SequenceInterval]]\nA list of the entry classes for each tier.\n\n\ntier_names\nlist[str]\nA list of tier names\n\n\nxmax\nfloat\nMaximum time\n\n\nxmin\nfloat\nMinimum time\n\n\n[]\n\nIndexable. Returns a SequenceTier\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_intervals_at_time\nGet intervals at time\n\n\nshow_structure\nShow the hierarchical structure\n\n\n\n\n\nsequences.tiers.TierGroup.get_intervals_at_time(time)\nGet intervals at time\nReturns a list of intervals at time for each tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\nTime in intervals\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[int]\nA list of interval indices, one for each tier in tier_list\n\n\n\n\n\n\n\nsequences.tiers.TierGroup.show_structure()\nShow the hierarchical structure"
  },
  {
    "objectID": "reference/TierGroup.html#parameters",
    "href": "reference/TierGroup.html#parameters",
    "title": "TierGroup",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntiers\nlist[SequenceTier]\nA list of sequence tiers that are meant to be in hierarchical relationships with eachother\n[SequenceTier()]"
  },
  {
    "objectID": "reference/TierGroup.html#attributes",
    "href": "reference/TierGroup.html#attributes",
    "title": "TierGroup",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntier_list\nlist[SequenceTier]\nList of sequence tiers that have been related.\n\n\nentry_classes\nlist[Type[SequenceInterval]]\nA list of the entry classes for each tier.\n\n\ntier_names\nlist[str]\nA list of tier names\n\n\nxmax\nfloat\nMaximum time\n\n\nxmin\nfloat\nMinimum time\n\n\n[]\n\nIndexable. Returns a SequenceTier"
  },
  {
    "objectID": "reference/TierGroup.html#methods",
    "href": "reference/TierGroup.html#methods",
    "title": "TierGroup",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_intervals_at_time\nGet intervals at time\n\n\nshow_structure\nShow the hierarchical structure\n\n\n\n\n\nsequences.tiers.TierGroup.get_intervals_at_time(time)\nGet intervals at time\nReturns a list of intervals at time for each tier.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\nTime in intervals\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[int]\nA list of interval indices, one for each tier in tier_list\n\n\n\n\n\n\n\nsequences.tiers.TierGroup.show_structure()\nShow the hierarchical structure"
  },
  {
    "objectID": "reference/Ranges.html",
    "href": "reference/Ranges.html",
    "title": "Ranges",
    "section": "",
    "text": "polar.polar_classes.Ranges(self, Interval)\nA ranges interval\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequenceInterval\n\n\nrange\nnp.array\nThe f0 range\n\n\nlow\nfloat\nThe low value of the f0 range\n\n\nhigh\nfloat\nThe high value of the f0 range\n\n\nbands\nnp.array\nThe break points in the f0 range (6 break points defining 5 bands)"
  },
  {
    "objectID": "reference/Ranges.html#attributes",
    "href": "reference/Ranges.html#attributes",
    "title": "Ranges",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequenceInterval\n\n\nrange\nnp.array\nThe f0 range\n\n\nlow\nfloat\nThe low value of the f0 range\n\n\nhigh\nfloat\nThe high value of the f0 range\n\n\nbands\nnp.array\nThe break points in the f0 range (6 break points defining 5 bands)"
  },
  {
    "objectID": "reference/SequencePoint.html",
    "href": "reference/SequencePoint.html",
    "title": "SequencePoint",
    "section": "",
    "text": "points.points.SequencePoint(self, point=Point(0, ''))\nSequence Points\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npoint\nPoint\na praatio.point object\nPoint(0, '')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n…\n\nAll attributes and methods included in PrecedenceMixins and InTierMixins\n\n\ntime\nfloat\nTime value associated with the point.\n\n\nlabel\nstr\nLabel associated with the point\n\n\nintier\nSequencePointTier\nIf the SequencePoint is within a tier, this accesses the tier.\n\n\nfol\nSequencePoint\nIf defined, the following SequencePoint within the same tier\n\n\nprev\nSequencePoint\nIf defined, the previous SequencePoint within the same tier.\n\n\nfol_distance\nfloat\nIf fol is defined, the difference between the current point and fol (should be &gt;= 0)\n\n\nprev_distance\nfloat\nif prev is defined, the difference between the current point and prev (should be &lt;= 0).\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndistance_from\nDistance from an entry\n\n\nget_interval_at_point\nGet the SequenceInterval the current point falls within\n\n\nget_interval_index_at_time\nGet the index of an interval at the point’s time\n\n\n\n\n\npoints.points.SequencePoint.distance_from(entry)\nDistance from an entry\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSelf | SequenceInterval\nA point or an interval to get the distance of the current point from\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nfloat | np.array\na single value in the case of a point, a numpy array in the case of an interval.\n\n\n\n\n\n\n\npoints.points.SequencePoint.get_interval_at_point(tier=None)\nGet the SequenceInterval the current point falls within\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nSequenceTier\nThe sequence tier within which to look for a matching SequenceInterval\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval\nThe SequenceInterval within which the current point falls\n\n\n\n\n\n\n\npoints.points.SequencePoint.get_interval_index_at_time(tier=None)\nGet the index of an interval at the point’s time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nSequenceTier\nA SequenceTier.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the SequenceInterval within which the point falls"
  },
  {
    "objectID": "reference/SequencePoint.html#parameters",
    "href": "reference/SequencePoint.html#parameters",
    "title": "SequencePoint",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\npoint\nPoint\na praatio.point object\nPoint(0, '')"
  },
  {
    "objectID": "reference/SequencePoint.html#attributes",
    "href": "reference/SequencePoint.html#attributes",
    "title": "SequencePoint",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n…\n\nAll attributes and methods included in PrecedenceMixins and InTierMixins\n\n\ntime\nfloat\nTime value associated with the point.\n\n\nlabel\nstr\nLabel associated with the point\n\n\nintier\nSequencePointTier\nIf the SequencePoint is within a tier, this accesses the tier.\n\n\nfol\nSequencePoint\nIf defined, the following SequencePoint within the same tier\n\n\nprev\nSequencePoint\nIf defined, the previous SequencePoint within the same tier.\n\n\nfol_distance\nfloat\nIf fol is defined, the difference between the current point and fol (should be &gt;= 0)\n\n\nprev_distance\nfloat\nif prev is defined, the difference between the current point and prev (should be &lt;= 0)."
  },
  {
    "objectID": "reference/SequencePoint.html#methods",
    "href": "reference/SequencePoint.html#methods",
    "title": "SequencePoint",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndistance_from\nDistance from an entry\n\n\nget_interval_at_point\nGet the SequenceInterval the current point falls within\n\n\nget_interval_index_at_time\nGet the index of an interval at the point’s time\n\n\n\n\n\npoints.points.SequencePoint.distance_from(entry)\nDistance from an entry\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSelf | SequenceInterval\nA point or an interval to get the distance of the current point from\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nfloat | np.array\na single value in the case of a point, a numpy array in the case of an interval.\n\n\n\n\n\n\n\npoints.points.SequencePoint.get_interval_at_point(tier=None)\nGet the SequenceInterval the current point falls within\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nSequenceTier\nThe sequence tier within which to look for a matching SequenceInterval\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval\nThe SequenceInterval within which the current point falls\n\n\n\n\n\n\n\npoints.points.SequencePoint.get_interval_index_at_time(tier=None)\nGet the index of an interval at the point’s time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nSequenceTier\nA SequenceTier.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nThe index of the SequenceInterval within which the point falls"
  },
  {
    "objectID": "reference/SequenceTier.html",
    "href": "reference/SequenceTier.html",
    "title": "SequenceTier",
    "section": "",
    "text": "sequences.tiers.SequenceTier(self, tier=[], entry_class=SequenceInterval)\nA sequence tier\nGiven a praatio IntervalTier or list of Intervals, creates entry_class instances for every interval.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntier\nlist[Interval] | IntervalTier\nA list of interval entries. Defaults to [Interval(None, None, None)].\n[]\n\n\nentry_class\nType[SequenceInterval]\nThe sequence class for this tier. Defaults to SequenceInterval.\nSequenceInterval\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsequence_list\nlist[SequenceInterval]\n\n\n\nentry_class\nType[SequenceInterval]\n\n\n\nsuperset_class\nType[SequenceInterval]\n\n\n\nsubset_class\nType[SequenceInterval]\n\n\n\nstarts\nnp.ndarray[np.float64]\n\n\n\nends\nnp.ndarray[np.float64]\n\n\n\nlabels\nlist[str]\n\n\n\nxmin\nfloat\n\n\n\nxmax\nfloat\n\n\n\nname\nstr\n\n\n\n[]\n\nIndexable. Returns a SequenceInterval\n\n\n\n\nIterable\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_interval_at_time\nGets interval index at specified time\n\n\npop\nPop an interval\n\n\nreturn_tier\nReturns a praatio interval tier\n\n\nsave_as_tg\nSaves as a textgrid\n\n\n\n\n\nsequences.tiers.SequenceTier.get_interval_at_time(time)\nGets interval index at specified time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime at which to get an interval\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nIndex of the interval\n\n\n\n\n\n\n\nsequences.tiers.SequenceTier.pop(entry)\nPop an interval\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSequenceInterval\nInterval to pop\nrequired\n\n\n\n\n\n\n\nsequences.tiers.SequenceTier.return_tier()\nReturns a praatio interval tier\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.data_classes.interval_tier.IntervalTier\nA praatio interval tier. Useful for saving results back as a Praat TextGrid.\n\n\n\n\n\n\n\nsequences.tiers.SequenceTier.save_as_tg(save_path)\nSaves as a textgrid\nUses praatio.data_classes.textgrid.Textgrid.save() method.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\nOutput path\nrequired"
  },
  {
    "objectID": "reference/SequenceTier.html#parameters",
    "href": "reference/SequenceTier.html#parameters",
    "title": "SequenceTier",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntier\nlist[Interval] | IntervalTier\nA list of interval entries. Defaults to [Interval(None, None, None)].\n[]\n\n\nentry_class\nType[SequenceInterval]\nThe sequence class for this tier. Defaults to SequenceInterval.\nSequenceInterval"
  },
  {
    "objectID": "reference/SequenceTier.html#attributes",
    "href": "reference/SequenceTier.html#attributes",
    "title": "SequenceTier",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nsequence_list\nlist[SequenceInterval]\n\n\n\nentry_class\nType[SequenceInterval]\n\n\n\nsuperset_class\nType[SequenceInterval]\n\n\n\nsubset_class\nType[SequenceInterval]\n\n\n\nstarts\nnp.ndarray[np.float64]\n\n\n\nends\nnp.ndarray[np.float64]\n\n\n\nlabels\nlist[str]\n\n\n\nxmin\nfloat\n\n\n\nxmax\nfloat\n\n\n\nname\nstr\n\n\n\n[]\n\nIndexable. Returns a SequenceInterval\n\n\n\n\nIterable"
  },
  {
    "objectID": "reference/SequenceTier.html#methods",
    "href": "reference/SequenceTier.html#methods",
    "title": "SequenceTier",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_interval_at_time\nGets interval index at specified time\n\n\npop\nPop an interval\n\n\nreturn_tier\nReturns a praatio interval tier\n\n\nsave_as_tg\nSaves as a textgrid\n\n\n\n\n\nsequences.tiers.SequenceTier.get_interval_at_time(time)\nGets interval index at specified time\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntime\nfloat\ntime at which to get an interval\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nint\nIndex of the interval\n\n\n\n\n\n\n\nsequences.tiers.SequenceTier.pop(entry)\nPop an interval\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nentry\nSequenceInterval\nInterval to pop\nrequired\n\n\n\n\n\n\n\nsequences.tiers.SequenceTier.return_tier()\nReturns a praatio interval tier\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.data_classes.interval_tier.IntervalTier\nA praatio interval tier. Useful for saving results back as a Praat TextGrid.\n\n\n\n\n\n\n\nsequences.tiers.SequenceTier.save_as_tg(save_path)\nSaves as a textgrid\nUses praatio.data_classes.textgrid.Textgrid.save() method.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsave_path\nstr\nOutput path\nrequired"
  },
  {
    "objectID": "reference/InTierMixins.html",
    "href": "reference/InTierMixins.html",
    "title": "InTierMixins",
    "section": "",
    "text": "mixins.mixins.InTierMixins()\nMethods and attrubites relating Sequence* objects to tiers.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntier_index\nint\nIndex of the current entry within its tier\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_tierwise\nGet entry by relative tier index\n\n\nreturn_interval\nReturn current object as Interval\n\n\nreturn_point\nReturn current object as Point\n\n\n\n\n\nmixins.mixins.InTierMixins.get_tierwise(idx=0)\nGet entry by relative tier index\nReturns a SequenceInterval or SequencePoint from an index position relative to the current sequence.\n\nidx=0 - Returns the current entry\nidx=1 - Returns the following entry on the tier. If the current entry is in the final position within its subset list, this will not be the same as .fol\nidx=-1 - Returns the previous entry on the tier. If the current entry is in the initial position within its subset list, this will not be the same as .prev\n\nThis will raise an ordinary IndexError if the relative index exceeds the length of the tier.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nidx\nint\nThe relative tier index at which to retrieve a sequence. Defaults to 0.\n0\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval | SequencePoint\nThe entry at the relative index\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_interval()\nReturn current object as Interval\nWill be useful for saving back to textgrid\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Interval\nA praatio Interval object\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_point()\nReturn current object as Point\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Point\nA praatio Point\n\n\nPoint\nobject"
  },
  {
    "objectID": "reference/InTierMixins.html#attributes",
    "href": "reference/InTierMixins.html#attributes",
    "title": "InTierMixins",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntier_index\nint\nIndex of the current entry within its tier"
  },
  {
    "objectID": "reference/InTierMixins.html#methods",
    "href": "reference/InTierMixins.html#methods",
    "title": "InTierMixins",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_tierwise\nGet entry by relative tier index\n\n\nreturn_interval\nReturn current object as Interval\n\n\nreturn_point\nReturn current object as Point\n\n\n\n\n\nmixins.mixins.InTierMixins.get_tierwise(idx=0)\nGet entry by relative tier index\nReturns a SequenceInterval or SequencePoint from an index position relative to the current sequence.\n\nidx=0 - Returns the current entry\nidx=1 - Returns the following entry on the tier. If the current entry is in the final position within its subset list, this will not be the same as .fol\nidx=-1 - Returns the previous entry on the tier. If the current entry is in the initial position within its subset list, this will not be the same as .prev\n\nThis will raise an ordinary IndexError if the relative index exceeds the length of the tier.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nidx\nint\nThe relative tier index at which to retrieve a sequence. Defaults to 0.\n0\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSequenceInterval | SequencePoint\nThe entry at the relative index\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_interval()\nReturn current object as Interval\nWill be useful for saving back to textgrid\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Interval\nA praatio Interval object\n\n\n\n\n\n\n\nmixins.mixins.InTierMixins.return_point()\nReturn current object as Point\n\n\n\n\n\nType\nDescription\n\n\n\n\npraatio.utilities.constants.Point\nA praatio Point\n\n\nPoint\nobject"
  },
  {
    "objectID": "reference/ToBI.html",
    "href": "reference/ToBI.html",
    "title": "ToBI",
    "section": "",
    "text": "polar.polar_classes.ToBI(self, Point=None)\nA ToBI point class\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint"
  },
  {
    "objectID": "reference/ToBI.html#attributes",
    "href": "reference/ToBI.html#attributes",
    "title": "ToBI",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n…\n\nAll methods and attributes from SequencePoint"
  }
]